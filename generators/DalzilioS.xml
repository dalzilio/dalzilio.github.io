<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE bibliography SYSTEM "biblio.dtd" [
  <!ENTITY LNCS "Lecture Notes in Computer Science">
  <!ENTITY SV "Springer-Verlag">
  <!ENTITY IEEE "IEEE Computer Society">
  <!ENTITY dalzilio "<name>Dal Zilio</name><forename>Silvano</forename>">
  <!ENTITY amadio "<name>Amadio</name><forename>Roberto M.</forename>">
  <!ENTITY acciai "<name>Acciai</name><forename>Lucia</forename>">
  <!ENTITY abid "<name>Abid</name><forename>Nouha</forename>">
  <!ENTITY didier "<name>Le Botlan</name><forename>Didier</forename>">
  <!ENTITY lugiez "<name>Lugiez</name><forename>Denis</forename>">
  <!ENTITY gordon "<name>Gordon</name><forename>Andrew D.</forename>">
  <!ENTITY gascon "<name>Gascon</name><forename>R&#x00E9;gis</forename>">
  <!ENTITY boreale "<name>Boreale</name> <forename>Michele</forename>">
  <!ENTITY francois "<name>Vernadat</name> <forename>Fran&#x00E7;ois</forename>">
  <!ENTITY bernard "<name>Berthomieu</name> <forename>Bernard</forename>">
  <!ENTITY mamoun "<name>Filali</name> <forename>Mamoun</forename>">
  <!ENTITY nawal "<name>Guermouche</name> <forename>Nawal</forename>">
  <!ENTITY bodeveix "<name>Bodeveix</name> <forename>Jean-Paul</forename>">
  <!ENTITY chaudet "<name>Chaudet</name> <forename>Christelle</forename>">
  <!ENTITY rodrigo "<name>Tacla Saad</name> <forename>Rodrigo</forename>">
  <!ENTITY dissaux "<name>Dissaux</name> <forename>Pierre</forename>">
  <!ENTITY gaufillet "<name>Gaufillet</name> <forename>Pierre</forename>">
  <!ENTITY heim "<name>Heim</name> <forename>S&#x00E9;bastien</forename>">
  <!ENTITY pantel "<name>Pantel</name> <forename>Marc</forename>">
  <!ENTITY lukasz "<name>Fronc</name> <forename>Lukasz</forename>">
  <!ENTITY bourdil "<name>Bourdil</name> <forename>Pierre-Alain</forename>">
  <!ENTITY avellaneda "<name>Avellaneda</name> <forename>Florent</forename>">
  <!ENTITY raclet "<name>Raclet</name> <forename>Jean-Baptiste</forename>">
  <!ENTITY jenn "<name>Jenn</name> <forename>Éric</forename>">
  <!ENTITY hladik "<name>Hladik</name> <forename>Pierre-Emmanuel</forename>">
  <!ENTITY foughali "<name>Foughali</name> <forename>Mohammed</forename>">
  <!ENTITY namat "<name>Amat</name> <forename>Nicolas</forename>">
  <!ENTITY hujsa "<name>Hujsa</name>  <forename>Thomas</forename>">
  <!ENTITY mdash "&#8212;">
]>

<bibliography author="DalzilioS">
  <inproceedings key="learnbs">
    <authors>
      <author>&dalzilio;</author>
      <author>
        <name>Bernard</name>
        <forename>Thierry M.</forename>
      </author>
    </authors>
    <title>Learning Binary Shapes as Compression and its Cellular Implementation</title>
    <booktitle>
      <short>ACCV'95</short>
      <long>2nd Asian Conference on Computer Vision</long>
    </booktitle>
    <year>1995</year>
    <volume>II</volume>
    <pages bgn="616" end="620" />
    <month>12</month>
    <url type="pdf" href="Papers/accv95.pdf" />
    <abstract>
      <p>We present a methodology to learn how to recognize binary shapes, based on the principle
        that recognition may be understood as a process of information compression. Our approach,
        directed towards adaptive target tracking applications, is intended to be well suited to
        fine-grained parallel architectures, such as cellular automata machines that can be
        integrated in artificial retinas. This methodology, fruitfully explained within the frame of
        mathematical morphology, is then particularized in the perspective of its actual
        implementation.</p>
    </abstract>
  </inproceedings>

  <techreport key="rr3244">
    <authors>
      <author>&dalzilio;</author>
    </authors>
    <title>Implicit Polymorphic Type System for the Blue Calculus</title>
    <institution>INRIA</institution>
    <year>1997</year>
    <number>3244</number>
    <month>9</month>
    <url type="pdf" href="Papers/RR-3244.pdf" />
    <hal type="INRIA">00073445</hal>
    <abstract>
      <p>The Blue Calculus is a direct extension of both the lambda and the pi calculi. In a
        preliminary work from Gérard Boudol, a simple type system was given that incorporates
        Curry's type inference for the lambda-calculus. In the present paper we study an implicit
        polymorphic type system, adapted from the ML typing discipline. Our typing system enjoys
        subject reduction and principal type properties and we give results on the complexity for
        the type inference problem. These are interesting results for the blue calculus as a
        programming notation for higher-order concurrency.</p>
    </abstract>
    <copyright organization="INRIA" />
    <tags>Semantics, Concurrency</tags>
  </techreport>

  <inproceedings key="bouncingobj">
    <authors>
      <author>&dalzilio;</author>
    </authors>
    <title>Quiet and Bouncing Objects: Two Migration Abstractions in a Simple Distributed Blue
      Calculus</title>
    <booktitle>
      <short>SOAP'98</short>
      <long>1st International Workshop on Semantics of Objects as Processes</long>
    </booktitle>
    <year>1998</year>
    <publisher>BRICS Notes Series</publisher>
    <volume>NS-98-5</volume>
    <month>7</month>
    <pages bgn="35" end="42" />
    <url type="pdf" href="Papers/bouncing.pdf" />
    <hal>00091895</hal>
    <abstract>
      <p>In this paper, we study a model of migrating objects based on the blue calculus, extended
        with a very simple system of localities. We show how two migration behaviors can be defined,
        namely those of bouncing and quiet objects. These migration control abstractions are defined
        separately from other aspects of the object definition and can be easily reused, thus
        providing more flexibility in the definition of migration constraints.</p>
    </abstract>
    <copyright organization="BRICS" />
    <tags>Semantics, Objects</tags>
  </inproceedings>

  <inproceedings key="blueobj">
    <authors>
      <author>&dalzilio;</author>
    </authors>
    <title>Concurrent Objects in the Blue Calculus</title>
    <booktitle>
      <short>JFLA'99</short>
      <long>10ème Journées Francophones des Langages Applicatifs</long>
    </booktitle>
    <month>2</month>
    <year>1999</year>
    <url type="pdf" href="Papers/blueobj-II.pdf" />
    <abstract>
      <p>We describe a model of concurrent objects based on the blue calculus, a typed variant of
        the asynchronous pi-calculus in which the notion of function is directly embedded. We
        propose a definition for a simple concurrent object-based calculus and show how objects can
        be translated in BC. We also present the type system for objects derived from our definition
        and we verify the expressiveness of the object calculus by giving a direct and adequate
        interpretation of Abadi and Cardelli object calculus, that preserves subtyping.</p>
    </abstract>
    <copyright organization="INRIA" />
    <tags>Semantics, Objects</tags>
  </inproceedings>

  <techreport key="rr3664">
    <authors>
      <author>&dalzilio;</author>
    </authors>
    <title>A Bisimulation for the Blue Calculus</title>
    <institution>INRIA</institution>
    <year>1999</year>
    <number>3664</number>
    <month>4</month>
    <url type="pdf" href="Papers/RR-3664.pdf" />
    <hal type="INRIA">00073008</hal>
    <abstract>
      <p>The Blue calculus is a direct extension of both the lambda and the pi calculi. In this
        report, we define an equivalence for this calculus based on barbed congruence, and we prove
        the validity of the replication laws. For example, we prove that a replicated resource,
        shared by many processes, can be safely copied and distributed.</p>
    </abstract>
    <copyright organization="INRIA" />
    <tags>Semantics, Concurrency</tags>
  </techreport>

  <phdthesis key="these">
    <authors>
      <author>&dalzilio;</author>
    </authors>
    <title>Le calcul bleu: types et objets</title>
    <school>Université de Nice - Sophia-Antipolis</school>
    <year>1999</year>
    <month>7</month>
    <url type="pdf" href="Papers/these-dalzilio.pdf" />
    <abstract>
      <p>The blue calculus, defined by Boudol, is a variant of the polyadic pi-calculus that
        directly embeds the notion of function. In this thesis, we define a version of the blue
        calculus, extended with records, and we study whether it provides a good basis for a typed
        concurrent programming language with imperative, higher-order, and object features. We
        notably study the modeling of the functional and object oriented programming idioms, and the
        addition of polymorphic typing and inheritance.</p>
      <p>The thesis is divided into four parts. The first part consists of a detailed analysis of
        the blue calculus and its expressiveness. In the second part, we define a behavioral
        equivalence based on the classical notion of barbed congruence, and a labeled bisimulation
        that is finer than this congruence. We then use up-to proof techniques to prove the validity
        of several algebraic laws like, for example, an analogous of Milner's replication theorem
        for the pi-calculus.</p>
      <p>In the third part, we study type systems for the blue calculus. Starting from a simple
        implicit type system that encompasses both Curry's type system for the lambda-calculus, and
        Milner's sorting for the pi-calculus, we successively propose three extensions of increasing
        complexity. We study the addition of subtyping, then parametric polymorphism. In this last
        case, we also study the decidability of the type inference problem. Finally, we study an
        higher-order type system with recursion and a particular form of bounded universal
        quantification. This system, that is suitable for the typing of objects, can be intuitively
        viewed as a Curry style presentation of F-sub. We prove the soundness of this system.</p>
      <p>The last part of the thesis is devoted to the study of objects in the blue calculus. We
        give a typed interpretation of two popular object calculi, namely Abadi-Cardelli's object
        calculus &#8212; in its functional version, and in its concurrent version &#8212;, and the
        calculus of extensible objects defined by Fisher and Mitchell. Our main contribution is a
        typed interpretation of the calculus of extensible objects that preserves subtyping.</p>
    </abstract>
    <copyright organization="INRIA" />
    <tags>Semantics, Concurrency</tags>
  </phdthesis>

  <inproceedings key="interpextobj">
    <authors>
      <author>
        <name>Boudol</name>
        <forename>Gérard</forename>
      </author>
      <author>&dalzilio;</author>
    </authors>
    <title>An Interpretation of Extensible Objects</title>
    <booktitle>
      <short>FCT'99</short>
      <long>12th International Symposium on Fundamentals of Computation Theory</long>
    </booktitle>
    <year>1999</year>
    <month>8</month>
    <volume>1684</volume>
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <pages bgn="148" end="160" />
    <url type="pdf" href="Papers/fct-full.pdf" />
    <doi>10.1007/3-540-48321-7_11</doi>
    <abstract>
      <p>We provide a translation of Fisher-Honsell-Mitchell's delegation-based object calculus with
        subtyping into a lambda-calculus with extensible records. The target type system is an
        extension of the system F&#969; of dependent types with recursion, extensible records and a
        form of bounded universal quantification. We show that our translation is computationally
        adequate, that the typing rules of Fisher-Honsell-Mitchell's calculus can be derived in a
        rather simple and natural way, and that our system enjoys the standard subject reduction
        property.</p>
    </abstract>
    <copyright organization="Springer" />
    <tags>Objects</tags>
  </inproceedings>

  <inproceedings key="spacongdec">
    <authors>
      <author>&dalzilio;</author>
    </authors>
    <title>Spatial Congruence for the Ambients is Decidable</title>
    <booktitle>
      <short>ASIAN'00</short>
      <long>6th Asian Computing Science Conference</long>
    </booktitle>
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <volume>1961</volume>
    <year>2000</year>
    <url type="pdf" href="Papers/asian2000.pdf" />
    <month>11</month>
    <doi>10.1007/3-540-44464-5_8</doi>
    <abstract>
      <p>The ambient calculus of Cardelli and Gordon is a process calculus for describing mobile
        computation where processes may reside within a hierarchy of locations, called ambients. The
        dynamic semantics of this calculus is presented in a chemical style that allows for a
        compact and simple formulation. In this semantics, an equivalence relation, the spatial
        congruence, is defined on the top of an unlabelled transition system, the reduction system.
        Reduction is used to represent a real step of evolution (in time), while spatial congruence
        is used to identify processes up to particular (spatial) rearrangements.</p>
      <p>In this paper, we show that it is decidable to check whether two ambient calculus processes
        are spatially congruent, or not. Our proof is based on a natural and intuitive
        interpretation of Mobility processes as edge-labelled finite-depth trees. This allows us to
        concentrate on the subtle interaction between two key operators of the ambient calculus,
        namely restriction, that accounts for the dynamic generation of new location names, and
        replication, used to encode recursion. The result of our study is the definition of an
        algorithm to decide spatial congruence and a definition of a normal form for processes that
        is useful in the proof of interesting equivalence laws.</p>
    </abstract>
    <copyright organization="Springer" />
    <referto key="spacongdecRR">An extended version of this paper appears as
      Technical Report MSR-TR-2000-41, Microsoft Research, May 2000.</referto>
    <tags>Concurrency, Mobility, Mobile Ambients</tags>
  </inproceedings>

  <techreport key="spacongdecRR">
    <authors>
      <author>&dalzilio;</author>
    </authors>
    <title>Spatial Congruence for the Ambients is Decidable</title>
    <institution>Microsoft Research</institution>
    <year>2000</year>
    <number>MSR-TR-2000-41</number>
    <url type="pdf" href="Papers/tr-2000-41.pdf" />
    <month>5</month>
    <abstract>
      <p>The ambient calculus of Cardelli and Gordon is a process calculus for describing mobile
        computation where processes may reside within a hierarchy of locations, called ambients. The
        dynamic semantics of this calculus is presented in a chemical style that allows for a
        compact and simple formulation. In this semantics, an equivalence relation, the spatial
        congruence, is defined on the top of an unlabelled transition system, the reduction system.
        Reduction is used to represent a real step of evolution (in time), while spatial congruence
        is used to identify processes up to particular (spatial) rearrangements.</p>
      <p>In this paper, we show that it is decidable to check whether two ambient calculus processes
        are spatially congruent, or not. Our proof is based on a natural and intuitive
        interpretation of ambient processes as edge-labelled finite-depth trees. This allows us to
        concentrate on the subtle interaction between two key operators of the ambient calculus,
        namely restriction, that accounts for the dynamic generation of new location names, and
        replication, used to encode recursion. The result of our study is the definition of an
        algorithm to decide spatial congruence and a definition of a normal form for processes that
        is useful in the proof of interesting equivalence laws.</p>
    </abstract>
    <copyright organization="Microsoft" />
    <referby key="spacongdec" />
    <tags>Concurrency, Mobility, Mobile Ambients</tags>
  </techreport>

  <inproceedings key="movep">
    <authors>
      <author>&dalzilio;</author>
    </authors>
    <title>Mobile Processes: a Commented Bibliography</title>
    <booktitle>
      <short>MOVEP'2K</short>
      <long>4th Summer school on Modelling and Verification of Parallel processes</long>
    </booktitle>
    <month>6</month>
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <volume>2067</volume>
    <year>2001</year>
    <pages bgn="206" end="222" />
    <url type="pdf" href="Papers/survey.pdf" />
    <abstract>
      <p>We propose a short bibliographic survey of calculi for mobile processes. Contrasting with
        other similar exercises, we consider two related, but distinct, notions of mobile processes,
        namely labile processes, which can exhibit changes of their interaction structure, as
        modelled in the pi-calculus, and motile processes, which can exhibit movement, as modelled
        in the ambient calculus of Cardelli and Gordon. A common attribute of the algebraic
        frameworks presented in this paper is that they all rely on a notion of name as first class
        value.</p>
    </abstract>
    <copyright organization="Springer" />
    <tags>Concurrency, Semantics, Pi calculus</tags>
  </inproceedings>

  <inproceedings key="interptypcoo">
    <authors>
      <author>&dalzilio;</author>
    </authors>
    <title>An Interpretation of Typed Concurrent Objects in the Blue Calculus</title>
    <booktitle>
      <short>IFIP TCS 2000</short>
      <long>International Conference on Theoretical Computer Science</long>
    </booktitle>
    <year>2000</year>
    <month>8</month>
    <volume>1872</volume>
    <pages bgn="409" end="424" />
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <url type="pdf" href="Papers/ifiptcs2000.pdf" />
    <doi>10.1007/3-540-44929-9_29</doi>
    <abstract>
      <p>We propose an interpretation of a typed concurrent calculus of objects based on the model
        of Abadi and Cardelli imperative object calculus. The target of our interpretation is a
        version of the blue calculus, a variant of the pi-calculus that directly contains the lambda
        calculus, with record and first-order types. We show that reduction and type judgments can
        be derived in a rather simple and natural way, and that our encoding can be extended to
        self-types and synchronization primitives. We also prove some equational laws on objects.</p>
    </abstract>
    <copyright organization="Springer" />
    <tags>Concurrency, Objects</tags>
  </inproceedings>

  <inproceedings key="regions">
    <authors>
      <author>&dalzilio;</author>
      <author>&gordon;</author>
    </authors>
    <title>Region analysis and a pi-calculus with groups</title>
    <booktitle>
      <short>MFCS 2000</short>
      <long>25th International Symposium on Mathematical Foundations of Computer Science</long>
    </booktitle>
    <year>2000</year>
    <month>8</month>
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <volume>1893</volume>
    <pages bgn="1" end="20" />
    <url type="pdf" href="Papers/regions-mfcs.pdf" />
    <doi>10.1007/3-540-44612-5_1</doi>
    <abstract>
      <p>We show that the typed region calculus of Tofte and Talpin can be encoded in a typed
        pi-calculus equipped with name groups and a novel effect analysis. In the region calculus,
        each boxed value has a statically determined region in which it is stored. Regions are
        allocated and de-allocated according to a stack discipline, thus improving memory
        management. The idea of name groups arose in the typed ambient calculus of Cardelli, Ghelli,
        and Gordon. There, and in our pi-calculus, each name has a statically determined group to
        which it belongs. Groups allow for type-checking of certain mobility properties, as well as
        effect analyses. Our encoding makes precise the intuitive correspondence between regions and
        groups. We propose a new formulation of the type preservation property of the region
        calculus, which avoids Tofte and Talpin's rather elaborate co-inductive formulation. We
        prove the encoding preserves the static and dynamic semantics of the region calculus. Our
        proof of the correctness of region de-allocation shows it to be a specific instance of a
        general garbage collection principle for the pi-calculus with effects. We propose new
        equational laws for _letregion_, analogous to scope mobility laws in the pi-calculus, and
        show them sound in our semantics. </p>
    </abstract>
    <copyright organization="Springer" />
    <referto key="regionsrr"> An extended version of this paper appears as
      Technical Report MSR-TR-2000-57, Microsoft Research, August
      2000.</referto>
    <referto key="regionsjfp">An abridged version appears in
      the Journal of Functional Programming 12(3):229-292, May 2002.</referto>
    <tags>Concurrency, Semantics, Pi calculus</tags>
  </inproceedings>

  <techreport key="regionsrr">
    <authors>
      <author>&dalzilio;</author>
      <author>&gordon;</author>
    </authors>
    <title>Region analysis and a pi-calculus with groups</title>
    <institution>Microsoft Research</institution>
    <year>2000</year>
    <number>MSR-TR-2000-57</number>
    <month>8</month>
    <url type="pdf" href="Papers/tr-2000-57.pdf" />
    <abstract>
      <p>We show that the typed region calculus of Tofte and Talpin can be encoded in a typed
        pi-calculus equipped with name groups and a novel effect analysis. In the region calculus,
        each boxed value has a statically determined region in which it is stored. Regions are
        allocated and de-allocated according to a stack discipline, thus improving memory
        management. The idea of name groups arose in the typed ambient calculus of Cardelli, Ghelli,
        and Gordon. There, and in our pi-calculus, each name has a statically determined group to
        which it belongs. Groups allow for type-checking of certain mobility properties, as well as
        effect analyses. Our encoding makes precise the intuitive correspondence between regions and
        groups. We propose a new formulation of the type preservation property of the region
        calculus, which avoids Tofte and Talpin's rather elaborate co-inductive formulation. We
        prove the encoding preserves the static and dynamic semantics of the region calculus. Our
        proof of the correctness of region de-allocation shows it to be a specific instance of a
        general garbage collection principle for the pi-calculus with effects.</p>
    </abstract>
    <copyright organization="Microsoft" />
    <referby key="regions" />
  </techreport>

  <inproceedings key="complexity">
    <authors>
      <author>
        <name>Charatonik</name>
        <forename>Witold</forename>
      </author>
      <author>&dalzilio;</author>
      <author>&gordon;</author>
      <author>
        <name>Mukhopadhyay</name>
        <forename>Supratik</forename>
      </author>
      <author>
        <name>Talbot</name>
        <forename>Jean-Marc</forename>
      </author>
    </authors>
    <title>The Complexity of Model Checking Mobile Ambients</title>
    <booktitle>
      <short>FoSSaCS 2001</short>
      <long>4th International Conference on Foundations of Software Science and Computation
        Structures</long>
    </booktitle>
    <pages bgn="152" end="167" />
    <year>2001</year>
    <volume>2030</volume>
    <series>&LNCS;</series>
    <month>4</month>
    <publisher>&SV;</publisher>
    <url type="pdf" href="Papers/fossacs2001.pdf" />
    <doi>10.1007/3-540-45315-6_10</doi>
    <abstract>
      <p>We settle the complexity bounds of the model checking problem for the replication-free
        ambient calculus with public names against the ambient logic without parallel adjunct. We
        show that the problem is PSPACE-complete. For the complexity upper-bound, we devise a new
        representation of processes that remains of polynomial size during process execution; this
        allows us to keep the model checking procedure in polynomial space. Moreover, we prove
        PSPACE-hardness of the problem for several quite simple fragments of the calculus and the
        logic; this suggests that there are no interesting fragments with polynomial-time model
        checking algorithms.</p>
    </abstract>
    <copyright organization="Springer" />
    <referto key="modelcheckambient">An extended version of this paper appears
      in Theoretical Computer Science 308(1):277-331, Nov. 2003, under the
      title: Model Checking Mobile Ambients.</referto>
    <referto key="modelcheckambientrr">An extended version of this paper also
      appears as Technical Report MSR-TR-2001-03, Microsoft Research, May
      2001.</referto>
    <tags>Concurrency, Mobility, Mobile Ambients</tags>
  </inproceedings>

  <techreport key="modelcheckambientrr">
    <authors>
      <author>
        <name>Charatonik</name>
        <forename>Witold</forename>
      </author>
      <author>&dalzilio;</author>
      <author>&gordon;</author>
      <author>
        <name>Mukhopadhyay</name>
        <forename>Supratik</forename>
      </author>
      <author>
        <name>Talbot</name>
        <forename>Jean-Marc</forename>
      </author>
    </authors>
    <title>The Complexity of Model Checking Mobile Ambients</title>
    <institution>Microsoft Research</institution>
    <year>2001</year>
    <number>MSR-TR-2001-03</number>
    <month>5</month>
    <url type="pdf" href="Papers/tr-2001-03.pdf" />
    <abstract>
      <p>We settle the complexity bounds of the model checking problem for the replication-free
        ambient calculus with public names against the ambient logic without parallel adjunct. We
        show that the problem is PSPACE-complete. For the complexity upper-bound, we devise a new
        representation of processes that remains of polynomial size during process execution; this
        allows us to keep the model checking procedure in polynomial space. Moreover, we prove
        PSPACE-hardness of the problem for several quite simple fragments of the calculus and the
        logic; this suggests that there are no interesting fragments with polynomial-time model
        checking algorithms.</p>
    </abstract>
    <copyright organization="Microsoft" />
    <referby key="complexity" />
  </techreport>

  <inproceedings key="fics2001">
    <authors>
      <author>&dalzilio;</author>
    </authors>
    <title>Fixed Points in the Ambient Logic</title>
    <booktitle>
      <short>FICS 2001</short>
      <long>3rd Workshop on Fixed Points in Computer Science</long>
    </booktitle>
    <year>2001</year>
    <month>9</month>
    <url type="pdf" href="Papers/puzzle.pdf" />
    <abstract>
      <p>We present an extension of the ambient logic with fixed points operators in the style of
        the &#956;-calculus. We give a simple syntactic condition for the equivalence between
        minimal and maximal fixpoint formulas and show how to subsume spatial analogues of the usual
        box and diamond operators.</p>
    </abstract>
    <tags>Concurrency, Semantics, Mobile Ambients</tags>
  </inproceedings>

  <article key="regionsjfp">
    <authors>
      <author>&dalzilio;</author>
      <author>&gordon;</author>
    </authors>
    <title>Region analysis and a pi-calculus with groups</title>
    <journal>Journal of Functional Programming</journal>
    <year>2002</year>
    <volume>12</volume>
    <number>3</number>
    <pages bgn="229" end="292" />
    <month>5</month>
    <doi>10.1017/S0956796801004270</doi>
    <abstract>
      <p>We show that the typed region calculus of Tofte and Talpin can be encoded in a typed
        pi-calculus equipped with name groups and a novel effect analysis. In the region calculus,
        each boxed value has a statically determined region in which it is stored. Regions are
        allocated and de-allocated according to a stack discipline, thus improving memory
        management. The idea of name groups arose in the typed ambient calculus of Cardelli, Ghelli,
        and Gordon. There, and in our pi-calculus, each name has a statically determined group to
        which it belongs. Groups allow for type-checking of certain mobility properties, as well as
        effect analyses. Our encoding makes precise the intuitive correspondence between regions and
        groups. We propose a new formulation of the type preservation property of the region
        calculus, which avoids Tofte and Talpin's rather elaborate co-inductive formulation. We
        prove the encoding preserves the static and dynamic semantics of the region calculus. Our
        proof of the correctness of region de-allocation shows it to be a specific instance of a
        general garbage collection principle for the pi-calculus with effects. We propose new
        equational laws for _letregion_, analogous to scope mobility laws in the pi-calculus, and
        show them sound in our semantics. </p>
    </abstract>
    <!-- <referby key="regions" /> -->
    <tags>Concurrency, Semantics, Pi calculus</tags>
  </article>

  <techreport key="multitapresb">
    <authors>
      <author>&dalzilio;</author>
      <author>&lugiez;</author>
    </authors>
    <title>Multitrees Automata, Presburger's Constraints and Tree Logics</title>
    <institution>LIF</institution>
    <year>2002</year>
    <number>08-2002</number>
    <month>6</month>
    <url type="pdf" href="Papers/rrlif-08-2002.pdf" />
    <abstract>
      <p>We describe _multitree automata_ and a related logic on multitrees. Multitrees are
        extensions of trees with both associative and associative-commutative symbols that may bear
        arbitrary numbers of sons. An originality of our approach is that transitions of an
        automaton are restricted using Presburger's constraints. The benefit of this extension is
        that we generalize, all together, automata with equality and disequalities constraints as
        well as counting constraints. This new class of automata appears very general as it may
        encompass hedge automata, a simple yet effective model for XML schemata, feature tree
        automata, automata with constraints between brothers and automata with arithmetical
        constraints. Moreover, the class of recognizable languages enjoys all the typical good
        properties of traditional regular languages: closure under boolean operations and
        composition by associative and associative-commutative operators, determinisation,
        decidability of the test for emptiness, ... </p>
      <p>We apply our automata to query languages for XML-like documents and to automated inductive
        theorem proving based on rewriting, obtaining each time new results. Using a classical
        connection between logic and automata, we design a decidable logic for (multi)trees that can
        be used as a foundation for querying XML-like document. This proposition has the same
        flavour as a query language for semi-structured recently proposed by Cardelli and Ghelli.
        The same tree logic is used to yield decidable cases of inductive reducibility modulo
        associativity-commutativity, a key property in inductive theorem proving based on rewriting.</p>
    </abstract>
    <project>tralala</project>
    <tags>XML, Automata, Semantics</tags>
    <copyright organization="LIF" />
  </techreport>

  <techreport key="xmlsheavesRR">
    <authors>
      <author>&dalzilio;</author>
      <author>&lugiez;</author>
    </authors>
    <title>XML Schema, Tree Logic and Sheaves Automata</title>
    <institution>INRIA</institution>
    <year>2002</year>
    <number>4631</number>
    <month>11</month>
    <url type="pdf" href="Papers/RR-4631.pdf" />
    <hal type="INRIA">00071954</hal>
    <abstract>
      <p>We describe a new class of tree automata, and a related logic on trees, with applications
        to the processing of XML documents and XML schemas.</p>
      <p>XML documents, and other forms of semi-structured data, may be roughly described as edge
        labeled trees. Therefore it is natural to use tree automata to reason on them and try to
        apply the classical connection between automata, logic and query languages. This approach
        has been followed by various researchers and has given some notable results, especially when
        dealing with Document Type Definition (DTD), the simplest standard for defining XML
        documents validity. But additional work is needed to take into account XML schema, a more
        advanced standard, for which regular tree automata are not satisfactory. A major reason for
        this inadequacy is the presence of an associative-commutative operator in the schema
        language, inherited from the &amp;-operator of SGML, and the inherent limitations of regular
        tree automata in dealing with associative-commutative algebras.</p>
      <p>The class of automata considered here, called sheaves automata, is a tailored version of
        automata for unranked trees with both associative and associative-commutative symbols
        already proposed by the authors. In order to handle both ordered and unordered operators, we
        combine the transition relation of regular tree automaton with regular word expression and
        counting constraints. This extension appears quite natural since, when no counting
        constraints occurs, we obtain hedge automata, a simple model for XML schemata, and when no
        constraints occur, we obtain regular tree automata.</p>
      <p>Building on the classical connection between logic and automata, we also present a
        decidable tree logic that embeds XML Schema as a plain subset.</p>
    </abstract>
    <copyright organization="INRIA" />
    <referby key="xmlsheaves" />
  </techreport>

  <inproceedings key="xmlsheaves">
    <authors>
      <author>&dalzilio;</author>
      <author>&lugiez;</author>
    </authors>
    <title>XML Schema, Tree Logic and Sheaves Automata</title>
    <booktitle>
      <short>RTA 2003</short>
      <long>14th International Conference on Rewriting Techniques and Applications</long>
    </booktitle>
    <pages bgn="246" end="263" />
    <year>2003</year>
    <volume>2706</volume>
    <series>&LNCS;</series>
    <month>6</month>
    <publisher>&SV;</publisher>
    <url type="pdf" href="Papers/sheaves-xml.pdf" />
    <doi>10.1007/3-540-44881-0_18</doi>
    <note>Best Paper Award</note>
    <abstract>
      <p>XML documents, and other forms of semi-structured data, may be roughly described as edge
        labeled trees; it is therefore natural to use tree automata to reason on them. This idea has
        already been successfully applied in the context of _Document Type Definition_ (DTD), the
        simplest standard for defining XML documents validity, but additional work is needed to take
        into account XML Schema, a more advanced standard, for which regular tree automata are not
        satisfactory. In this paper, we define a tree logic that directly embeds XML Schema as a
        plain subset as well as a new class of automata for unranked trees, used to decide this
        logic, which is well-suited to the processing of XML documents and schemas. </p>
    </abstract>
    <copyright organization="Springer" />
    <referto key="xmlsheavesRR">An extended version of this paper appears as
      Research Report 4631, INRIA, November 2002.</referto>
    <referto key="xmlsheavesAAECC">An abridged version appears in Applicable
      Algebra in Engineering, Communication and Computing 17(5):337-377, October
      2006.</referto>
    <tags>XML, Automata, Semantics</tags>
    <project>tralala</project>
  </inproceedings>

  <article key="modelcheckambient">
    <authors>
      <author>
        <name>Charatonik</name>
        <forename>Witold</forename>
      </author>
      <author>&dalzilio;</author>
      <author>&gordon;</author>
      <author>
        <name>Mukhopadhyay</name>
        <forename>Supratik</forename>
      </author>
      <author>
        <name>Talbot</name>
        <forename>Jean-Marc</forename>
      </author>
    </authors>
    <title>Model Checking Mobile Ambients</title>
    <journal>Theoretical Computer Science</journal>
    <year>2003</year>
    <volume>308</volume>
    <number>1</number>
    <pages bgn="277" end="331" />
    <month>11</month>
    <doi>10.1016/S0304-3975(02)00832-0</doi>
    <abstract>
      <p>We settle the complexity bounds of the model checking problem for the ambient calculus with
        public names against the ambient logic. We show that if either the calculus contains
        replication or the logic contains the guarantee operator, the problem is undecidable. In the
        case of the replication-free calculus and guarantee-free logic we prove that the problem is
        PSPACE-complete. For the complexity upper bound, we devise a new representation of processes
        that remains of polynomial size during process execution; this allows us to keep the model
        checking procedure in polynomial space. Moreover, we prove PSPACE-hardness of the problem
        for several quite simple fragments of the calculus and the logic; this suggests that there
        are no interesting fragments with polynomial-time model checking algorithms.</p>
    </abstract>
    <tags>Concurrency, Mobility, Mobile Ambients</tags>
    <!-- <referby key="complexity" /> -->
  </article>

  <techreport key="logiccountRR">
    <authors>
      <author>&dalzilio;</author>
      <author>&lugiez;</author>
      <author>
        <name>Meyssonnier</name>
        <forename>Charles</forename>
      </author>
    </authors>
    <title>A Logic You Can Count On</title>
    <institution>INRIA</institution>
    <year>2003</year>
    <number>5022</number>
    <month>11</month>
    <url type="pdf" href="Papers/RR-5022.pdf" />
    <hal type="INRIA">00071562</hal>
    <abstract>
      <p>We prove the decidability of the quantifier-free, static fragment of ambient logic, with
        composition adjunct and iteration, which corresponds to a kind of regular expression
        language for semistructured data. The essence of this result is a surprising connection
        between formulas of the ambient logic and counting constraints on (nested) vectors of
        integers. Our proof method is based on a new class of tree automata for unranked, unordered
        trees, which may result in practical algorithms for deciding the satisfiability of a
        formula. A benefit of our approach is to naturally lead to an extension of the logic with
        recursive definitions, which is also decidable. Finally, we identify a simple syntactic
        restriction on formulas that improves the effectiveness of our algorithms on large examples.</p>
    </abstract>
    <copyright organization="LIF" />
    <referby key="logiccount" />
  </techreport>

  <inproceedings key="logiccount">
    <authors>
      <author>&dalzilio;</author>
      <author>&lugiez;</author>
      <author>
        <name>Meyssonnier</name>
        <forename>Charles</forename>
      </author>
    </authors>
    <title>A Logic you Can Count On</title>
    <booktitle>
      <short>POPL 2004</short>
      <long>31st Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</long>
    </booktitle>
    <publisher>ACM Press</publisher>
    <doi>10.1145/982962.964013</doi>
    <url type="pdf" href="Papers/logiccount.pdf" />
    <year>2004</year>
    <month>1</month>
    <abstract>
      <p>We prove the decidability of the quantifier-free, static fragment of ambient logic, with
        composition adjunct and iteration, which corresponds to a kind of regular expression
        language for semistructured data. The essence of this result is a surprising connection
        between formulas of the ambient logic and counting constraints on (nested) vectors of
        integers.</p>
      <p>Our proof method is based on a new class of tree automata for unranked, unordered trees,
        which may result in practical algorithms for deciding the satisfiability of a formula. A
        benefit of our approach is to naturally lead to an extension of the logic with recursive
        definitions, which is also decidable. Finally, we identify a simple syntactic restriction on
        formulas that improves the effectiveness of our algorithms on large examples.</p>
    </abstract>
    <copyright organization="ACM" />
    <referto key="logiccountRR">An extended version of this paper appears as
      Research Report 5022, INRIA, November 2003.</referto>
    <tags>XML, Automata, Mobile Ambients</tags>
    <project>tralala</project>
  </inproceedings>

  <inproceedings key="PBsystpn">
    <authors>
      <author>&dalzilio;</author>
      <author>
        <name>Formenti</name>
        <forename>Enrico</forename>
      </author>
    </authors>
    <title>On the Dynamics of PB Systems: A Petri Net View</title>
    <booktitle>
      <short>WMC 2003</short>
      <long>Workshop on Membrane Computing</long>
    </booktitle>
    <pages bgn="153" end="167" />
    <year>2004</year>
    <month>1</month>
    <volume>2933</volume>
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <doi>10.1007/b95207</doi>
    <url type="pdf" href="Papers/final-pbs.pdf" />
    <abstract>
      <p>We study dynamical properties of PB systems, a new computational model of biological
        processes, and propose a compositional encoding of PB systems into Petri nets. Building on
        this relation, we show that three properties: _boundedness_, _reachability_ and _cyclicity_,
        which we claim are useful in practice, are all decidable. </p>
    </abstract>
    <copyright organization="Springer" />
    <tags>Concurrency, Semantics, Petri</tags>
  </inproceedings>

  <techreport key="fbvrbRR">
    <authors>
      <author>&amadio;</author>
      <author>
        <name>Coupet-Grimal</name>
        <forename>Solange</forename>
      </author>
      <author>&dalzilio;</author>
      <author>
        <name>Jakubiec</name>
        <forename>Line</forename>
      </author>
    </authors>
    <title>A Functional Scenario for Bytecode Verification of Resource Bounds</title>
    <institution>LIF</institution>
    <year>2004</year>
    <number>17</number>
    <url type="pdf" href="Papers/rrlif-17-2004.pdf" />
    <month>1</month>
    <abstract>
      <p>We define a simple stack machine for a first-order functional language and show how to
        perform type, size, and termination verifications at the level of the bytecode of the
        machine. In particular, we show that a combination of size verification based on
        quasi-interpretations and of termination verification based on lexicographic path orders
        leads to an explicit bound on the space required for the execution.</p>
    </abstract>
    <copyright organization="LIF" />
    <referby key="fsbvrb" />
  </techreport>

  <inproceedings key="fbvrbSPACE">
    <authors>
      <author>&amadio;</author>
      <author>
        <name>Coupet-Grimal</name>
        <forename>Solange</forename>
      </author>
      <author>&dalzilio;</author>
      <author>
        <name>Jakubiec</name>
        <forename>Line</forename>
      </author>
    </authors>
    <title>A Functional Scenario for Bytecode Verification of Resource Bounds</title>
    <booktitle>
      <short>SPACE 2004</short>
      <long>2nd workshop on Semantics, Program Analysis, and Computing Environments for Memory
        Management</long>
    </booktitle>
    <year>2004</year>
    <month>1</month>
    <!-- <referby key="fsbvrb" /> -->
    <project>criss</project>
    <tags>Complexity, Resource Control</tags>
  </inproceedings>

  <inproceedings key="fsbvrb">
    <authors>
      <author>&amadio;</author>
      <author>
        <name>Coupet-Grimal</name>
        <forename>Solange</forename>
      </author>
      <author>&dalzilio;</author>
      <author>
        <name>Jakubiec</name>
        <forename>Line</forename>
      </author>
    </authors>
    <title>A Functional Scenario for Bytecode Verification of Resource Bounds</title>
    <booktitle>
      <short>CSL 2004</short>
      <long>18th International Conference on Computer Science Logic</long>
    </booktitle>
    <year>2004</year>
    <month>9</month>
    <volume>3210</volume>
    <pages bgn="265" end="279" />
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <doi>10.1007/b100120</doi>
    <url type="pdf" href="Papers/fsbvrb.pdf" />
    <abstract>
      <p>We define a simple stack machine for a first-order functional language and show how to
        perform type, size, and termination verifications at the level of the bytecode of the
        machine. In particular, we show that a combination of size verification based on
        quasi-interpretations and of termination verification based on lexicographic path orders
        leads to an explicit bound on the space required for the execution.</p>
    </abstract>
    <copyright organization="Springer" />
    <referto key="fbvrbSPACE">An abridged version of this paper was first
      presented at the 2nd workshop on Semantics, Program Analysis, and
      Computing Environments for Memory Management (SPACE 2004).</referto>
    <referto key="fbvrbRR">An extended version appears as Research Report
      17-2004, LIF, Jan. 2004.</referto>
    <project>criss</project>
    <tags>Complexity, Resource Control</tags>
  </inproceedings>

  <techreport key="rcsctRR">
    <authors>
      <author>&amadio;</author>
      <author>&dalzilio;</author>
    </authors>
    <title>Resource Control for Synchronous Cooperative Threads</title>
    <institution>LIF</institution>
    <year>2004</year>
    <number>22</number>
    <url type="pdf" href="Papers/rrlif-22-2004.pdf" />
    <month>5</month>
    <abstract>
      <p>We develop new methods to statically bound the resources needed for the execution of
        systems of concurrent, interactive threads.</p>
      <p>Our study is concerned with a synchronous model of interaction based on cooperative threads
        whose execution proceeds in synchronous rounds called instants. Our contribution is a system
        of compositional static analyses to guarantee that each instant terminates and to bound the
        size of the values computed by the system as a function of the size of its parameters at the
        beginning of the instant.</p>
      <p>Our method generalises an approach designed for first-order functional languages that
        relies on a combination of standard termination techniques for term rewriting systems and an
        analysis of the size of the computed values based on the notion of quasi-interpretation.</p>
      <p>We show that these two methods can be combined to obtain an explicit polynomial bound on
        the space needed for the execution of the system during an instant. We also provide evidence
        for the expressivity of our synchronous programming model and describe a bytecode for a
        related virtual machine.</p>
    </abstract>
    <copyright organization="LIF" />
    <referby key="rcsct" />
  </techreport>

  <inproceedings key="rcsct">
    <authors>
      <author>&amadio;</author>
      <author>&dalzilio;</author>
    </authors>
    <title>Resource Control for Synchronous Cooperative Threads</title>
    <booktitle>
      <short>CONCUR 2004</short>
      <long>15th International Conference on Concurrency Theory</long>
    </booktitle>
    <month>8</month>
    <year>2004</year>
    <volume>3170</volume>
    <pages bgn="68" end="82" />
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <url type="pdf" href="Papers/rcsct.pdf" />
    <doi>10.1016/j.tcs.2006.01.017</doi>
    <abstract>
      <p>We develop new methods to statically bound the resources needed for the execution of
        systems of concurrent, interactive threads. Our study is concerned with a synchronous model
        of interaction based on cooperative threads whose execution proceeds in synchronous rounds
        called instants. Our contribution is a system of compositional static analyses to guarantee
        that each instant terminates and to bound the size of the values computed by the system as a
        function of the size of its parameters at the beginning of the instant.</p>
      <p>Our method generalises an approach designed for first-order functional languages that
        relies on a combination of standard termination techniques for term rewriting systems and an
        analysis of the size of the computed values based on the notion of quasi-interpretation.
        These two methods can be combined to obtain an explicit polynomial bound on the resources
        needed for the execution of the system during an instant.</p>
    </abstract>
    <copyright organization="Springer" />
    <referto key="rcsctRR">An extended
      version of this paper appears as Research Report 22-2004, LIF, May
      2004.</referto>
    <referto key="rcsctTCS">An abridged version appears in
      Theoretical Computer Science 358(2-3):229-254, August 2006.</referto>
    <project>criss</project>
    <tags>Complexity, Resource Control</tags>
  </inproceedings>

  <techreport key="rbcvmRR">
    <authors>
      <author>&dalzilio;</author>
      <author>&gascon;</author>
    </authors>
    <title>Resource Bound Certification for a Tail-Recursive Virtual Machine</title>
    <institution>LIF</institution>
    <year>2005</year>
    <number>26</number>
    <url type="pdf" href="Papers/rrlif-26-2005.pdf" />
    <month>6</month>
    <abstract>
      <p>We define a method to statically bound the size of values computed during the execution of
        a program as a function of the size of its parameters. More precisely, we consider bytecode
        programs that should be executed on a simple stack machine with support for algebraic data
        types, pattern-matching and tail-recursion. Our size verification method is expressed as a
        static analysis, performed at the level of the bytecode, that relies on machine-checkable
        certificates. We follow here the usual assumption that code and certificates may be forged
        and should be checked before execution.</p>
      <p>Our approach extends a system of static analyses based on the notion of
        quasi-interpretations that has already been used to enforce resource bounds on first-order
        functional programs. This paper makes two additional contributions. First, we are able to
        check optimized programs, containing instructions for unconditional jumps and tail-recursive
        calls, and remove restrictions on the structure of the bytecode that was imposed in previous
        works. Second, we propose a direct algorithm that depends only on solving a set of
        arithmetical constraints.</p>
    </abstract>
    <copyright organization="LIF" />
    <referby key="rbcvm" />
  </techreport>

  <inproceedings key="tcqxmlNWPT">
    <authors>
      <author>&acciai;</author>
      <author>
        <name>Boreale</name>
        <forename>Michele</forename>
      </author>
      <author>&dalzilio;</author>
    </authors>
    <title>A Typed Calculus for Querying Distributed XML Documents</title>
    <booktitle>
      <short>NWPT 2005</short>
      <long>17th Nordic Workshop on Programming Theory</long>
    </booktitle>
    <url type="pdf" href="Papers/tcqxmlNWPT.pdf" />
    <year>2005</year>
    <month>10</month>
    <hal>00091917</hal>
    <abstract>
      <p>We study the problems related to querying large, distributed XML documents. Our proposal
        takes the form of a new process calculus in which XML data are processes that can be queried
        by means of concurrent pattern-matching expressions. What we achieve is a functional,
        strongly-typed programming model based on three main ingredients: an asynchronous process
        calculus in the style of Milner's pi-calculus and existing semantics for concurrent-ML; a
        model where documents and expressions are both represented as processes, and where
        evaluation is represented as a parallel composition of the two; a static type system based
        on regular expression types.</p>
    </abstract>
    <copyright organization="LIF" />
    <project>tralala</project>
    <tags>XML, Semantics, Concurrency</tags>
    <!-- <referby key="tcqxml" /> -->
  </inproceedings>

  <inproceedings key="rbcvm">
    <authors>
      <author>&dalzilio;</author>
      <author>&gascon;</author>
    </authors>
    <title>Resource Bound Certification for a Tail-Recursive Virtual Machine</title>
    <booktitle>
      <short>APLAS 2005</short>
      <long>3rd Asian Symposium on Programming Languages and Systems</long>
    </booktitle>
    <month>11</month>
    <year>2005</year>
    <volume>3780</volume>
    <pages bgn="247" end="263" />
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <doi>10.1007/11575467_17</doi>
    <url type="pdf" href="Papers/sizeaplas2005.pdf" />
    <abstract>
      <p> We define a method to statically bound the size of values computed during the execution of
        a program as a function of the size of its parameters. More precisely, we consider bytecode
        programs that should be executed on a simple stack machine with support for algebraic data
        types, pattern-matching and tail-recursion. Our size verification method is expressed as a
        static analysis, performed at the level of the bytecode, that relies on machine-checkable
        certificates. We follow here the usual assumption that code and certificates may be forged
        and should be checked before execution.</p>
      <p>Our approach extends a system of static analyses based on the notion of
        quasi-interpretations that has already been used to enforce resource bounds on first-order
        functional programs. This paper makes two additional contributions. First, we are able to
        check optimized programs, containing instructions for unconditional jumps and tail-recursive
        calls, and remove restrictions on the structure of the bytecode that was imposed in previous
        works. Second, we propose a direct algorithm that depends only on solving a set of
        arithmetical constraints.</p>
    </abstract>
    <copyright organization="Springer" />
    <referto key="rbcvmRR">An extended version of this paper appears as
      Research Report 26-2005, LIF, June 2005.</referto>
    <project>criss</project>
    <tags>Complexity, Resource Control</tags>
  </inproceedings>

  <techreport key="tcqxmlRR">
    <authors>
      <author>&acciai;</author>
      <author>
        <name>Boreale</name>
        <forename>Michele</forename>
      </author>
      <author>&dalzilio;</author>
    </authors>
    <title>A Typed Calculus for Querying Distributed XML Documents</title>
    <institution>LIF</institution>
    <year>2006</year>
    <number>29</number>
    <url type="pdf" href="Papers/rrlif-29-2006.pdf" />
    <month>1</month>
    <abstract>
      <p>We study the problems related to querying large, distributed XML documents. Our proposal
        takes the form of a new process calculus in which XML data are processes that can be queried
        by means of concurrent pattern-matching expressions. What we achieve is a functional,
        strongly-typed programming model based on three main ingredients: an asynchronous process
        calculus that draws features from &#x3C0;-calculus and concurrent-ML; a model where both
        documents and expressions are represented as processes, and where evaluation is represented
        as a parallel composition of the two; a static type system based on regular expression
        types.</p>
    </abstract>
    <copyright organization="LIF" />
    <referby key="tcqxml" />
  </techreport>

  <article key="rcsctTCS">
    <authors>
      <author>&amadio;</author>
      <author>&dalzilio;</author>
    </authors>
    <title>Resource Control for Synchronous Cooperative Threads</title>
    <journal>Theoretical Computer Science</journal>
    <volume>358</volume>
    <number>2-3</number>
    <pages bgn="229" end="254" />
    <year>2006</year>
    <month>8</month>
    <doi>10.1016/j.tcs.2006.01.017</doi>
    <arxiv>cs/0512057</arxiv>
    <hal>00015836</hal>
    <abstract>
      <p>We develop new methods to statically bound the resources needed for the execution of
        systems of concurrent, interactive threads.</p>
      <p>Our study is concerned with a _synchronous_ model of interaction based on cooperative
        threads whose execution proceeds in synchronous rounds called instants. Our contribution is
        a system of compositional static analyses to guarantee that each instant terminates and to
        bound the size of the values computed by the system as a function of the size of its
        parameters at the beginning of the instant. </p>
      <p>Our method generalises an approach designed for first-order functional languages that
        relies on a combination of standard termination techniques for term rewriting systems and an
        analysis of the size of the computed values based on the notion of quasi-interpretation.</p>
      <p>We show that these two methods can be combined to obtain an explicit polynomial bound on
        the resources needed for the execution of the system during an instant</p>
      <p>As a second contribution, we introduce a virtual machine and a related bytecode thus
        producing a precise description of the resources needed for the execution of a system. In
        this context, we present a suitable control flow analysis that allows to formulate the
        static analyses for resource control at byte code level.</p>
    </abstract>
    <project>criss</project>
    <tags>Complexity, Resource Control</tags>
    <!-- <referby key="rcsct" /> -->
  </article>

  <inproceedings key="tcqxml">
    <authors>
      <author>&acciai;</author>
      <author>&boreale;</author>
      <author>&dalzilio;</author>
    </authors>
    <title>A Typed Calculus for Querying Distributed XML Documents</title>
    <url type="pdf" href="Papers/tcqxml.pdf" />
    <booktitle>
      <short>TGC 2006</short>
      <long>2nd symposium on Trustworthy Global Computing</long>
    </booktitle>
    <year>2007</year>
    <volume>4661</volume>
    <pages bgn="167" end="182" />
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <month>1</month>
    <doi>10.1007/978-3-540-75336-0_11</doi>
    <abstract>
      <p>We study the problems related to querying large, distributed XML documents. Our proposal
        takes the form of a new process calculus in which XML data are processes that can be queried
        by means of concurrent pattern-matching expressions. What we achieve is a functional,
        strongly-typed programming model based on three main ingredients: an asynchronous process
        calculus in the style of Milner's pi-calculus and existing semantics for concurrent-ML; a
        model where documents and expressions are both represented as processes, and where
        evaluation is represented as a parallel composition of the two; a static type system based
        on regular expression types.</p>
    </abstract>
    <copyright organization="Springer" />
    <referto key="tcqxmlNWPT">An abridged version of this report has been
      presented at the 17th Nordic Workshop on Programming Theory, October
      2005.</referto>
    <referto key="tcqxmlRR">An extended version of this paper
      appears as Research Report 29-2006, LIF, January 2006.</referto>
    <project>tralala</project>
    <tags>XML, Semantics, Concurrency</tags>
  </inproceedings>

  <article key="xmlsheavesAAECC">
    <authors>
      <author>&dalzilio;</author>
      <author>&lugiez;</author>
    </authors>
    <title>XML schema, tree logic and sheaves automata</title>
    <journal>Applicable Algebra in Engineering, Communication and Computing</journal>
    <volume>17</volume>
    <number>5</number>
    <pages bgn="337" end="377" />
    <year>2006</year>
    <month>10</month>
    <doi>10.1007/s00200-006-0016-7</doi>
    <abstract>
      <p>XML documents may be roughly described as unranked, ordered trees and it is therefore
        natural to use tree automata to process or validate them. This idea has already been
        successfully applied in the context of Document Type Definition (DTD), the simplest standard
        for defining document validity, but additional work is needed to take into account XML
        Schema, a more advanced standard, for which regular tree automata are not satisfactory. In
        this paper, we introduce Sheaves Logic (SL), a new tree logic that extends the syntax of the
        (recursion-free fragment of) W3C XML Schema Definition Language (WXS). Then, we define a new
        class of automata for unranked trees that provides decision procedures for the basic
        questions about SL: model-checking; satisfiability; entailment. The same class of automata
        is also used to answer basic questions about WXS, including recursive schemas: decidability
        of type-checking documents; testing the emptiness of schemas; testing that a schema subsumes
        another one.</p>
    </abstract>
    <project>tralala</project>
    <tags>XML, Automata, Semantics</tags>
    <!-- <referby key="xmlsheaves" /> -->
  </article>

  <unpublished key="atccs-long">
    <authors>
      <author>&acciai;</author>
      <author>&boreale;</author>
      <author>&dalzilio;</author>
    </authors>
    <title>A Concurrent Calculus with Atomic Transactions</title>
    <url type="pdf" href="Papers/AtCCS_full.pdf" />
    <year>2006</year>
    <month>10</month>
    <arxiv>cs.LO/0610137</arxiv>
    <hal>00109264</hal>
    <abstract>
      <p>The _Software Transactional Memory_ (STM) model is an original approach for controlling
        concurrent accesses to ressources without the need for explicit lock-based synchronization
        mechanisms. A key feature of STM is to provide a way to group sequences of read and write
        actions inside _atomic blocks_, similar to database transactions, whose whole effect should
        occur atomically. </p>
      <p>In this paper, we investigate STM from a process algebra perspective and define an
        extension of asynchronous CCS with atomic blocks of actions. Our goal is not only to set a
        formal ground for reasoning on STM implementations but also to understand how this model
        fits with other concurrency control mechanisms. We also view this calculus as a test bed for
        extending process calculi with atomic transactions. This is an interesting direction for
        investigation since, for the most part, actual works that mix transactions with process
        calculi consider compensating transactions, a model that lacks all the well-known ACID
        properties.</p>
      <p>We show that the addition of atomic transactions results in a very expressive calculus,
        enough to easily encode other concurrent primitives such as guarded choice and
        multiset-synchronization (a la join-calculus). The correctness of our encodings is proved
        using a suitable notion of bisimulation equivalence. The equivalence is then applied to
        prove interesting "laws of transactions" and to obtain a simple normal form for
        transactions.</p>
    </abstract>
    <project>tralala</project>
    <tags>XML, Automata</tags>
    <!-- <referby key="atccs" /> -->
  </unpublished>

  <inproceedings key="atccs">
    <authors>
      <author>&acciai;</author>
      <author>&boreale;</author>
      <author>&dalzilio;</author>
    </authors>
    <title>A Concurrent Calculus with Atomic Transactions</title>
    <url type="pdf" href="Papers/AtCCS_full.pdf" />
    <booktitle>
      <short>ESOP 2007</short>
      <long>16th European Symposium on Programming</long>
    </booktitle>
    <year>2007</year>
    <month>3</month>
    <volume>4421</volume>
    <pages bgn="48" end="63" />
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <doi>10.1007/978-3-540-71316-6_5</doi>
    <abstract>
      <p>The _Software Transactional Memory_ (STM) model is an original approach for controlling
        concurrent accesses to ressources without the need for explicit lock-based synchronization
        mechanisms. A key feature of STM is to provide a way to group sequences of read and write
        actions inside _atomic blocks_, similar to database transactions, whose whole effect should
        occur atomically. </p>
      <p>In this paper, we investigate STM from a process algebra perspective and define an
        extension of asynchronous CCS with atomic blocks of actions. Our goal is not only to set a
        formal ground for reasoning on STM implementations but also to understand how this model
        fits with other concurrency control mechanisms. We also view this calculus as a test bed for
        extending process calculi with atomic transactions. This is an interesting direction for
        investigation since, for the most part, actual works that mix transactions with process
        calculi consider compensating transactions, a model that lacks all the well-known ACID
        properties.</p>
      <p>We show that the addition of atomic transactions results in a very expressive calculus,
        enough to easily encode other concurrent primitives such as guarded choice and
        multiset-synchronization (a la join-calculus). The correctness of our encodings is proved
        using a suitable notion of bisimulation equivalence. The equivalence is then applied to
        prove interesting ``laws of transactions'' and to obtain a simple normal form for
        transactions.</p>
    </abstract>
    <copyright organization="Springer" />
    <referto key="atccs-long">An extended version of this paper appears as
      arXiv preprint cs.LO/0610137, October 2006.</referto>
    <project>tralala</project>
    <tags>Semantics</tags>
  </inproceedings>

  <inproceedings key="ewdcobsgraph">
    <authors>
      <author>&rodrigo;</author>
      <author>&francois;</author>
      <author>&bernard;</author>
      <author>&dalzilio;</author>
    </authors>
    <title>Observation Graph implementation for TINA toolbox</title>
    <url type="pdf" href="Papers/ewdObsGraph.pdf" />
    <booktitle>
      <short>EWDC 2009</short>
      <long>12th European Workshop on Dependable Computing</long>
    </booktitle>
    <year>2009</year>
    <month>5</month>
    <hal>00380671</hal>
    <abstract>
      <p>Model Checking is a formal technique for the verification of finite systems. However, it is
        well known that this technique suffers from the state explosion problem. We describe work in
        progress to implement in the TINA toolbox an enumerative variant of a state based
        observation graph algorithm defined by Klai and Poitrenaud.</p>
    </abstract>
    <copyright organization="LAAS" />
    <tags>Verification, Petri</tags>
    <project>topcased</project>
  </inproceedings>

  <inproceedings key="aadltina">
    <authors>
      <author>&bernard;</author>
      <author>&bodeveix;</author>
      <author>&chaudet;</author>
      <author>&dalzilio;</author>
      <author>&mamoun;</author>
      <author>&francois;</author>
    </authors>
    <title>Formal Verification of AADL Specifications in the Topcased Environment</title>
    <url type="pdf" href="Papers/aadltina.pdf" />
    <booktitle>
      <short>Ada Europe 2009</short>
      <long>14th Ada-Europe International Conference</long>
    </booktitle>
    <year>2009</year>
    <month>6</month>
    <volume>5570</volume>
    <pages bgn="207" end="221" />
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <doi>10.1007/978-3-642-01924-1_15</doi>
    <abstract>
      <p>We describe a formal verification toolchain for AADL, the SAE Architecture Analysis and
        Design Language, enriched with its behavioral annex. Our approach is based on tools that are
        integrated in the Topcased environment. We give a high-level view of the tools involved and
        illustrate the successive transformations that take place during the verification process.</p>
    </abstract>
    <copyright organization="Springer" />
    <project>topcased</project>
    <tags>Verification, Architecture Languages</tags>
  </inproceedings>

  <unpublished key="etr2009">
    <authors>
      <author>&rodrigo;</author>
      <author>&dalzilio;</author>
      <author>&francois;</author>
      <author>&bernard;</author>
    </authors>
    <month>8</month>
    <title>Enumerative Parallel and Distributed State Space Construction</title>
    <note>presentation at École d'été Temps-Reél (ETR'09)</note>
    <year>2009</year>
    <url type="pdf" href="Papers/soa-distssc.pdf" />
    <hal>00494622</hal>
    <abstract>
      <p>Model Checking requires high end computers to verify complex systems. Consequently, it is
        interesting to use a multi-processors architectures in order to have more computational
        resources available to deal with bigger models. This work presents a survey of parallel and
        distributed state space construction for Model Checking purpose.</p>
    </abstract>
    <copyright organization="LAAS" />
    <tags>Verification, Parallelism</tags>
    <project>topcased</project>
  </unpublished>

  <inproceedings key="safeModelQuarteft">
    <authors>
      <author>&bernard;</author>
      <author>&bodeveix;</author>
      <author>&dalzilio;</author>
      <author>&mamoun;</author>
      <author>&pantel;</author>
      <author>&francois;</author>
    </authors>
    <title>Langage intermédiaire et transformations de modèles pour le développement de systèmes
      temps-réel: retour d'expérience sur la chaîne de vérification formelle Fiacre</title>
    <url type="pdf" href="Papers/safeModelQuarteft.pdf" />
    <booktitle>
      <short>IDM SafeModel 2010</short>
      <long>Journées sur l'Ingénierie Dirigée par les Modèles</long>
    </booktitle>
    <year>2010</year>
    <month>3</month>
    <hal>00492327</hal>
    <abstract>
      <p>We discuss the results obtained during the development of a formal veriﬁcation toolchain
        for AADL based on a model driven engineering approach. Our approach is characterized by the
        use of the pivot language FIACRE to facilitate veriﬁcation activities and transformations
        between models. We quickly analyse the ﬁrst return on experience and present ongoing work
        started in the scope of the Quarteft project to improve the veriﬁcation chain.</p>
    </abstract>
    <copyright organization="LAAS" />
    <tags>Verification, Architecture Languages, Fiacre</tags>
    <project>quarteft</project>
  </inproceedings>

  <inproceedings key="aadlTopcased">
    <authors>
      <author>&bernard;</author>
      <author>&bodeveix;</author>
      <author>&dalzilio;</author>
      <author>&dissaux;</author>
      <author>&mamoun;</author>
      <author>&heim;</author>
      <author>&gaufillet;</author>
      <author>&francois;</author>
    </authors>
    <title>Formal Verification of AADL models with Fiacre and Tina</title>
    <url type="pdf" href="Papers/aadlTopcased.pdf" />
    <booktitle>
      <short>ERTSS 2010</short>
      <long>5th International Congress and Exhibition on Embedded Real-Time Software and Systems</long>
    </booktitle>
    <year>2010</year>
    <month>5</month>
    <hal>00494348</hal>
    <doi>10.5281/zenodo.32930</doi>
    <abstract>
      <p>This paper details works undertaken in the scope of the Spices project concerning the
        behavioral verification of AADL models. We give a high-level view of the tools involved and
        describe the successive transformations performed by our verification process. We also
        report on an experiment carried out in order to evaluate our framework and give the first
        experimental results obtained on real-size models. This demonstrator models a network
        protocol in charge of data communications between an airplane and ground stations. From this
        study we draw a set of conclusions about the integration of model-checking tools in an
        industrial development process.</p>
    </abstract>
    <copyright organization="LAAS" />
    <tags>Verification, Architecture Languages, Fiacre</tags>
    <project>topcased</project>
  </inproceedings>

  <unpublished key="movep2010">
    <authors>
      <author>&abid;</author>
      <author>&dalzilio;</author>
    </authors>
    <month>6</month>
    <title>Real-time Extensions for the Fiacre modeling language</title>
    <note>presentation at MoVep 2010 &mdash; summer school on Modelling and Verifying Parallel
      Processes</note>
    <year>2010</year>
    <url type="pdf" href="Papers/movep2010.pdf" />
    <hal>00494617</hal>
    <abstract>
      <p>We present our ongoing research on the extension of the Fiacre language with real-time
        constructs and real-time verification patterns. Fiacre is a formal language with support for
        expressing concurrency and timing constraints; its goal is to act as an intermediate format
        for the formal verification of high-level modeling language, such as Architecture
        Description Languages or UML proﬁles for system modeling. Essentially, Fiacre is designed
        both as the target of model transformation engines from various languages, as well as the
        source language of compilers into verification toolboxes, namely Tina and CADP. Our
        motivations for extending Fiacre are to reduce the semantic gap between Fiacre and
        high-level description languages and to streamline our verification process.</p>
    </abstract>
    <copyright organization="LAAS" />
    <tags>Verification, Architecture Languages, Fiacre</tags>
    <project>quarteft</project>
  </unpublished>

  <inproceedings key="lockfreesscPDMC">
    <authors>
      <author>&bernard;</author>
      <author>&dalzilio;</author>
      <author>&rodrigo;</author>
    </authors>
    <title>A General Lock-Free Algorithm for Parallel State Space Construction</title>
    <url type="pdf" href="Papers/lockfreesscPDMC.pdf" />
    <booktitle>
      <short>PDMC 2010</short>
      <long>9th International Workshop on Parallel and Distributed Methods in verifiCation</long>
    </booktitle>
    <year>2010</year>
    <month>10</month>
    <publisher>&IEEE;</publisher>
    <doi>10.1109/PDMC-HiBi.2010.10</doi>
    <abstract>
      <p>Verification via model-checking is a very demanding activity in terms of computational
        resources. While there are still gains to be expected from algorithmic improvements, it is
        necessary to take advantage of the advances in computer hardware to tackle bigger models.
        Recent improvements in this area take the form of multiprocessor and multicore architectures
        with access to large memory space.</p>
      <p>We address the problem of generating the state space of finite-state transition systems;
        often a preliminary step for model-checking. We propose a novel algorithm for enumerative
        state space construction targeted at shared memory systems. Our approach relies on the use
        of two data structures: a shared Bloom filter to coordinate the state space exploration
        distributed among several processors and local dictionaries to store the states. The goal is
        to limit synchronization overheads and to increase the locality of memory access without
        having to make constant use of locks to ensure data integrity.</p>
      <p>Bloom filters have already been applied for the probabilistic verification of systems; they
        are compact data structures used to encode sets, but in a way that false positives are
        possible, while false negatives are not. We circumvent this limitation and propose an
        original multiphase algorithm to perform exhaustive, deterministic, state space generations.
        We assess the performance of our algorithm on different benchmarks and compare our results
        with the solution proposed by Inggs and Barringer.</p>
    </abstract>
    <copyright organization="LAAS" />
    <tags>Verification, Parallelism</tags>
    <project>topcased</project>
  </inproceedings>

  <techreport key="VerifTTS">
    <authors>
      <author>&dalzilio;</author>
      <author>&abid;</author>
      <author>&didier;</author>
    </authors>
    <url type="pdf" href="Papers/verifTTS.pdf" />
    <month>6</month>
    <title>Verification of Real-Time Specification Patterns on Time Transitions Systems</title>
    <number>11365</number>
    <institution>LAAS</institution>
    <year>2011</year>
    <hal>00593963</hal>
    <abstract>
      <p>We address the problem of checking properties of Time Transition Systems (TTS), a
        generalization of Time Petri Nets with data variables and priorities. We are specifically
        interested by time-related properties expressed using real-time specification patterns, a
        language inspired by properties commonly found during the analysis of reactive systems. Our
        verification approach is based on the use of observers in order to transform the
        verification of timed patterns into the verification of simpler LTL formulas. While the use
        of observers for model-checking timed extensions of temporal logics is fairly common, our
        approach is original in several ways. In addition to traditional observers based on the
        monitoring of places and transitions, we propose a new class of ob- servers based on the
        monitoring of data modifications that appears to be more efficient in practice. Moreover, we
        provide a formal framework to prove that observers are correct and non-intrusive, meaning
        that they do not affect the system under observation. Our approach has been integrated in a
        verification toolchain for Fiacre, a formal modeling language that can be compiled into TTS.</p>
    </abstract>
    <!-- <referby key="vecos2012verifpatterns" /> -->
    <copyright organization="LAAS" />
    <tags>Verification, Patterns, Time Petri nets</tags>
    <project>quarteft</project>
  </techreport>

  <techreport key="realtimePatterns">
    <authors>
      <author>&dalzilio;</author>
      <author>&abid;</author>
      <author>&didier;</author>
    </authors>
    <url type="pdf" href="Papers/realtimePatterns.pdf" />
    <month>6</month>
    <number>11364</number>
    <title>A Real-Time Specification Patterns Language</title>
    <institution>LAAS</institution>
    <year>2011</year>
    <hal>00593965</hal>
    <abstract>
      <p>We propose a real-time extension to the pattern specification language of Dwyer et al. Our
        contributions are twofold. First, we provide a formal pattern specification language that is
        simple enough to ease the specification of requirements by non-experts and rich enough to
        express general temporal constraints commonly found in reactive systems, such as compliance
        to deadlines, bounds on the worst-case execution time, etc. For each pattern, we give a
        precise definition based on three different formalisms: a denotational interpretation based
        on first-order formulas over timed traces; a definition based on a non-ambiguous, graphical
        notation; and a logic-based definition based on a translation into a real-time temporal
        logic. Our second contribution is a framework for the model-based verification of timed
        patterns. Our approach makes use of observers in order to reduce the verification of timed
        patterns to the verification of Linear Temporal Logic formulas. This framework has been
        integrated in a verification toolchain for Fiacre, a formal modeling language for real-time
        systems.</p>
    </abstract>
    <referby key="fmics2012patterns" />
    <referto key="t212QuarteftRR">A companion paper, presenting a previous
      version of ou pattern specification patterm, appears as Quarteft Project
      deliverable T2-12-B, January 2011.</referto>
    <copyright organization="LAAS" />
    <tags>Verification, Time Petri nets, Patterns</tags>
    <project>quarteft</project>
  </techreport>

  <techreport key="t212QuarteftRR">
    <authors>
      <author>&dalzilio;</author>
      <author>&abid;</author>
      <author>&didier;</author>
      <author>&bernard;</author>
      <author>&francois;</author>
      <author>&mamoun;</author>
      <author>&bodeveix;</author>
    </authors>
    <title>Definition of the Fiacre Real-Time Specification Patterns Language</title>
    <institution>Quarteft Project deliverable</institution>
    <year>2011</year>
    <number>T2-12-B</number>
    <url type="pdf" href="Papers/t212Prop.pdf" />
    <month>1</month>
    <abstract>
      <p>In this report, we deﬁne a high-level language for expressing properties over system
        expressed using Fiacre. Our approach is based on the deﬁnition of a set of property patterns
        inspired by properties that commonly occur during the specification of concurrent and
        reactive systems.</p>
    </abstract>
    <copyright organization="LAAS" />
    <tags>Verification, Fiacre, Patterns</tags>
    <project>quarteft</project>
  </techreport>

  <inproceedings key="timedreqtchoreographies">
    <authors>
      <author>&dalzilio;</author>
      <author>&nawal;</author>
    </authors>
    <month>10</month>
    <title>Towards Timed Requirement Verification for Service Choreographies</title>
    <booktitle>
      <short>CollaborateCom 2012</short>
      <long>8th IEEE International Conference on Collaborative Computing: Networking, Applications
        and Worksharing</long>
    </booktitle>
    <year>2012</year>
    <publisher>&IEEE;</publisher>
    <hal>00578436</hal>
    <doi>10.4108/icst.collaboratecom.2012.250441</doi>
    <url type="pdf" href="Papers/timedreqtchoreographies.pdf" />
    <abstract>
      <p>In this paper, we propose an approach for analyzing and validating a composition of
        services with respect to real time properties. We consider services defined using an
        extension of the Business Process Execution Language (BPEL) where timing constraints can be
        associated to the execution of an activity or define delays between events. The goal is to
        check whether a choreography of timed services satisfies given complex real time
        requirements. Our approach is based on a formal interpretation of timed choreographies in
        the Fiacre verification language that defines a precise model for the behavior of services
        and their timed interactions. We also rely on a logic-based language for property definition
        to formalize complex real-time requirements and on specific tooling for model-checking
        Fiacre specifications.</p>
    </abstract>
    <copyright organization="IEEE" />
    <tags>Verification, Fiacre</tags>
    <project>itemis</project>
  </inproceedings>

  <inproceedings key="mixedHashISPDC">
    <authors>
      <author>&rodrigo;</author>
      <author>&dalzilio;</author>
      <author>&bernard;</author>
    </authors>
    <title>Mixed Shared-Distributed Hash Tables Approaches for Parallel State Space Construction</title>
    <url type="pdf" href="Papers/mixedHashISPDC.pdf" />
    <hal>00523188</hal>
    <booktitle>
      <short>ISPDC 2011</short>
      <long>10th International Symposium on Parallel and Distributed Computing </long>
    </booktitle>
    <year>2011</year>
    <month>7</month>
    <doi>10.1109/ISPDC.2011.12</doi>
    <publisher>&IEEE;</publisher>
    <abstract>
      <p>We propose an algorithm for parallel state space construction based on an original
        concurrent data structure, called a localization table, that aims at better spatial and
        temporal balance. Our proposal is close in spirit to algorithms based on distributed hash
        tables, with the distinction that states are dynamically assigned to processors; i.e. we do
        not rely on an a-priori static partition of the state space.</p>
      <p>In our solution, every process keeps a share of the global state space. Data distribution
        and coordination between processes is made through the localization table, that is a
        lockless, thread-safe data structure that approximates the set of states being processed.
        The localization table is used to dynamically assign newly discovered states and can be
        queried to return the identity of the processor that own a given state. With this approach,
        we are able to consolidate a network of local hash tables into an (abstract) distributed one
        without sacriﬁcing memory afﬁnity – data that are “logically connected” and physically close
        to each others and without incurring performance costs associated to the use of locks to
        ensure data consistency.</p>
      <p>We evaluate the performance of our algorithm on different benchmarks and compare these
        results with other solutions proposed in the literature and with existing veriﬁcation tools.</p>
    </abstract>
    <copyright organization="IEEE" />
    <tags>Verification, Parallelism</tags>
    <project>topcased</project>
  </inproceedings>

  <unpublished key="etr2011">
    <authors>
      <author>&bernard;</author>
      <author>&bodeveix;</author>
      <author>&dalzilio;</author>
      <author>&mamoun;</author>
      <author>&francois;</author>
    </authors>
    <month>8</month>
    <title>Vérification formelle de spécifications AADL via FIACRE</title>
    <note>presentation at École d'été Temps-Reél (ETR'11)</note>
    <year>2011</year>
    <url type="pdf" href="Papers/etr2011.pdf" />
    <abstract></abstract>
    <copyright organization="LAAS" />
    <tags>Verification, Architecture Languages, Fiacre</tags>
    <project>topcased</project>
  </unpublished>

  <techreport key="mclcd">
    <authors>
      <author>&dalzilio;</author>
      <author>&rodrigo;</author>
      <author>&bernard;</author>
    </authors>
    <month>3</month>
    <title>Parallel Model Checking With Lazy Cycle Detection - MCLCD</title>
    <year>2012</year>
    <hal>00669752</hal>
    <institution>LAAS</institution>
    <url type="pdf" href="Papers/mclcd.pdf" />
    <number>12139</number>
    <abstract>
      <p>In this work, we present new algorithms for exhaustive parallel model checking that are as
        efficient as possible, but also ''friendly'' with respect to the work-sharing policies that
        are used for the state space generation (e.g. a work-stealing strategy): at no point do we
        impose a restriction on the way work is shared among the processors. This includes both the
        construction of the state space as the detection of cycles in parallel, which is is one of
        the key points of performance for the evaluation of more complex formulas.</p>
    </abstract>
    <copyright organization="LAAS" />
    <referby key="atva2012mclcd" />
    <tags>Verification, Parallelism</tags>
    <project>topcased</project>
  </techreport>

  <techreport key="rtgil">
    <authors>
      <author>&dalzilio;</author>
      <author>&abid;</author>
    </authors>
    <url type="pdf" href="Papers/rtgil.pdf" />
    <month>7</month>
    <number>12368</number>
    <title>A Timed Graphical Interval Logic</title>
    <institution>LAAS</institution>
    <year>2012</year>
    <abstract>
      <p> We define a graphical language for expressing timed requirements on concurrent systems.
        This formal language, called _Timed Graphical Interval Logic_ (TGIL), is inspired by
        realtime extensions of Dillon's et al Graphical Interval Logic and can be used as an
        alternative to timed extensions of temporal logic. We define the semantics of TGIL as a set
        of timed traces (using a dense time semantics) and illustrate its use in formal verification
        by describing a method for generating an observer from a TGIL specification. </p>
    </abstract>
    <copyright organization="LAAS" />
    <tags>Verification, Patterns</tags>
  </techreport>

  <techreport key="checkmodelcheck">
    <authors>
      <author>&dalzilio;</author>
      <author>&abid;</author>
      <author>&bernard;</author>
    </authors>
    <url type="pdf" href="Papers/checkmodelcheck.pdf" />
    <month>7</month>
    <number>12367</number>
    <title>Who Checks the Model-Checkers?</title>
    <institution>LAAS</institution>
    <year>2012</year>
    <abstract>
      <p> We describe a method for automatically testing a model-checker for timed behavioral
        properties. We consider the case of an observer-based model-checker, meaning that the
        relationship between a model and its specification is interpreted as the composition of the
        model with an observer of its behavior. In this context, a major problem is to prove the
        correctness of observers.</p>
      <p>In this work, we deal with systems expressed using Fiacre, a formal modelling language for
        realtime, reactive systems. For requirements, we consider specifications expressed using a
        set of realtime verification patterns, which are translated into observers. We describe a
        graphical verification method that has been used to gain confidence on our interpretation of
        patterns into observers. Our method provides a formal, automatic way to check that an
        observer for a specification pattern is correct, that is, a proof that an observer
        faithfully captures the semantics of its associated pattern. This general approach is
        complementary to the use of more heavy-duty verification methods, such as interactive
        theorem prover, and can be used to debug the implementation of new observers.</p>
    </abstract>
    <copyright organization="LAAS" />
    <tags>Verification, Fiacre</tags>
  </techreport>

  <inproceedings key="vecos2012verifpatterns">
    <authors>
      <author>&abid;</author>
      <author>&dalzilio;</author>
      <author>&didier;</author>
    </authors>
    <title>A Verified Approach for Checking Real-Time Specification Patterns</title>
    <url type="pdf" href="Papers/vecos2012verifpatterns.pdf" />
    <booktitle>
      <short>VECoS 2012</short>
      <long>6th International Workshop on Verification and Evaluation of Computer and Communication
        Systems </long>
    </booktitle>
    <year>2012</year>
    <month>9</month>
    <series>Electronic Workshops in Computing (eWiC)</series>
    <publisher>BCS</publisher>
    <abstract>
      <p> We propose a verified approach to the formal verification of timed properties using
        model-checking techniques. We focus on properties expressed using real-time specification
        patterns, which can be viewed as a subset of timed temporal logics that includes properties
        commonly found during the analysis of reactive systems. Our model-checking approach is based
        on the use of observers in order to transform the verification of timed patterns into the
        verification of simpler LTL formulas. While the use of observers for model-checking is quite
        common, our contribution is original in several ways. First, we define a formal framework to
        verify that our observers are correct and non-intrusive. Second, we define different classes
        of observers for each pattern and use a pragmatic approach in order to select the most
        efficient candidate in practice. This approach is implemented in an integrated verification
        tool chain for the Fiacre language.</p>
    </abstract>
    <copyright organization="LAAS" />
    <referto key="VerifTTS">An extended version of this paper appears as
      Research Report LAAS N°11365, June 2011.</referto>
    <referto key="IJCCBS2014verifpatterns">An abridged version appears in the
      International Journal of Critical Computer-Based Systems, 5:4-30,
      2014.</referto>
    <tags>Verification, Patterns</tags>
    <project>quarteft</project>
  </inproceedings>

  <inproceedings key="fmics2012patterns">
    <authors>
      <author>&abid;</author>
      <author>&dalzilio;</author>
      <author>&didier;</author>
    </authors>
    <title>Real-Time Specification Patterns and Tools</title>
    <url type="pdf" href="Papers/fmics2012patterns.pdf" />
    <booktitle>
      <short>FMICS 2012</short>
      <long>17th International Workshop on Formal Methods for Industrial Critical Systems</long>
    </booktitle>
    <year>2012</year>
    <month>9</month>
    <volume>7437</volume>
    <pages bgn="1" end="15" />
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <doi>10.1007/978-3-642-32469-7_1</doi>
    <abstract>
      <p>An issue limiting the adoption of model checking technologies by the industry is the
        ability, for non-experts, to express their requirements using the property languages
        supported by verification tools. This has motivated the definition of dedicated assertion
        languages for expressing temporal properties at a higher level. However, only a limited
        number of these formalisms support the definition of timing constraints. In this paper, we
        propose a set of specification patterns that can be used to express real-time requirements
        commonly found in the design of reactive systems. We also provide an integrated model
        checking tool chain for the verification of timed requirements on TTS, an extension of Timed
        Petri Nets with data variables and priorities.</p>
    </abstract>
    <copyright organization="Springer" />
    <referto key="realtimePatterns">An extended version of this paper appears
      as Research Report LAAS N°11364, June 2011.</referto>
    <tags>Verification, Time Petri nets, Patterns</tags>
    <project>quarteft</project>
  </inproceedings>

  <inproceedings key="atva2012mclcd">
    <authors>
      <author>&rodrigo;</author>
      <author>&dalzilio;</author>
      <author>&bernard;</author>
    </authors>
    <title>An Experiment on Parallel Model Checking of a CTL Fragment</title>
    <url type="pdf" href="Papers/atva2012mclcd.pdf" />
    <booktitle>
      <short>ATVA 2012</short>
      <long>10th International Symposium on Automated Technology for Verification and Analysis</long>
    </booktitle>
    <year>2012</year>
    <month>10</month>
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <abstract>
      <p> We propose a parallel algorithm for local, on the fly, model checking of a fragment of CTL
        that is well-suited for modern, multi-core architectures. This model-checking algorithm
        takes benefit from a parallel state space construction algorithm, which we described in a
        previous work, and shares the same basic set of principles: there are no assumptions on the
        models that can be analyzed; no restrictions on the way states are distributed; and no
        restrictions on the way work is shared among processors. We evaluate the performance of
        different versions of our algorithm and compare our results with those obtained using other
        parallel model checking tools. One of the most novel contributions of this work is to study
        a space-efficient variant for CTL model-checking that does not require to store the whole
        transition graph but that operates, instead, on a reverse spanning tree.</p>
    </abstract>
    <copyright organization="Springer" />
    <doi>10.1007/978-3-642-33386-6_23</doi>
    <referto key="mclcd">An extended version of this paper appears as Research
      Report LAAS N°12139, March 2012.</referto>
    <tags>Verification, Parallelism</tags>
    <project>topcased</project>
  </inproceedings>

  <article key="IJCCBS2014verifpatterns">
    <authors>
      <author>&abid;</author>
      <author>&dalzilio;</author>
      <author>&didier;</author>
    </authors>
    <title>A formal framework to specify and verify real-time properties on critical systems</title>
    <journal>International Journal of Critical Computer-Based Systems (IJCCBS)</journal>
    <volume>5</volume>
    <number>1/2</number>
    <pages bgn="4" end="30" />
    <year>2014</year>
    <month>3</month>
    <doi>10.1504/IJCCBS.2014.059593</doi>
    <abstract>
      <p> We propose a verified approach to the formal verification of timed properties using
        model-checking techniques. We focus on properties expressed using real-time specification
        patterns, which can be viewed as a subset of timed temporal logics that includes properties
        commonly found during the analysis of reactive systems. Our model-checking approach is based
        on the use of observers in order to transform the verification of timed patterns into the
        verification of simpler LTL formulas. While the use of observers for model-checking is quite
        common, our contribution is original in several ways. First, we define a formal framework to
        verify that our observers are correct and non-intrusive. Second, we define different classes
        of observers for each pattern and use a pragmatic approach in order to select the most
        efficient candidate in practice. This approach is implemented in an integrated verification
        tool chain for the Fiacre language.</p>
    </abstract>
    <!-- <referby key="vecos2012verifpatterns" /> -->
    <tags>Verification, Patterns</tags>
    <project>quarteft</project>
  </article>

  <techreport key="abz2014landinggearRR">
    <authors>
      <author>&lukasz;</author>
      <author>&dalzilio;</author>
      <author>&bernard;</author>
    </authors>
    <month>4</month>
    <title>Model-checking real-time properties of an aircraft landing gear system using fiacre</title>
    <year>2014</year>
    <hal>00967422</hal>
    <institution>LAAS</institution>
    <number>14104</number>
    <abstract>
      <p>We describe our experience with modeling the landing gear system of an aircraft using the
        formal specification language Fiacre. Our model takes into account the behavior and timing
        properties of both the physical parts and the control software of this system. We use this
        formal model to check safety and real-time properties on the system but also to find a safe
        bound on the maximal time needed for all gears to be down and locked (assuming the absence
        of failures). Our approach ultimately relies on the model-checking tool Tina, that provides
        state- space generation and model-checking algorithms for an extension of Time Petri Nets
        with data and priorities.</p>
    </abstract>
    <copyright organization="LAAS" />
    <referby key="abz2014landinggear" />
  </techreport>

  <inproceedings key="abz2014landinggear">
    <authors>
      <author>&lukasz;</author>
      <author>&dalzilio;</author>
      <author>&bernard;</author>
    </authors>
    <title>Model-Checking Real-Time Properties of an Aircraft Landing Gear System Using Fiacre</title>
    <url type="pdf" href="Papers/abz2014landinggear.pdf" />
    <booktitle>
      <short>ABZ 2014: The Landing Gear Case Study</short>
      <long>Case Study Track, 4th International Conference on Abstract State Machines, Alloy, B,
        TLA, VDM, and Z</long>
    </booktitle>
    <year>2014</year>
    <month>6</month>
    <volume>433</volume>
    <series>Communications in Computer and Information Science (CCS)</series>
    <publisher>&SV;</publisher>
    <doi>10.1007/978-3-319-07512-9_8</doi>
    <abstract>
      <p>We describe our experience with modeling the landing gear system of an aircraft using the
        formal specification language Fiacre. Our model takes into account the behavior and timing
        properties of both the physical parts and the control software of this system. We use this
        formal model to check safety and real-time properties on the system but also to find a safe
        bound on the maximal time needed for all gears to be down and locked (assuming the absence
        of failures). Our approach ultimately relies on the model-checking tool Tina, that provides
        state- space generation and model-checking algorithms for an extension of Time Petri Nets
        with data and priorities.</p>
    </abstract>
    <copyright organization="Springer" />
    <referto key="abz2014landinggearRR">An extended version of this paper
      appears as Research Report LAAS N°14104, April 2014.</referto>
    <tags>Verification, Use Case, Fiacre</tags>
    <project>openetcs</project>
  </inproceedings>

  <techreport key="fickleRR">
    <authors>
      <author>&lukasz;</author>
      <author>&dalzilio;</author>
      <author>&bernard;</author>
      <author>&francois;</author>
    </authors>
    <month>5</month>
    <url type="pdf" href="Papers/dyntpn.pdf" />
    <title>Time Petri nets with dynamic firing dates: semantics and applications</title>
    <year>2014</year>
    <hal>00984354</hal>
    <arxiv>1404.7067</arxiv>
    <institution>LAAS</institution>
    <number>14148</number>
    <abstract>
      <p>We define an extension of time Petri nets such that the time at which a transition can
        fire, also called its firing date, may be dynamically updated. Our extension provides two
        mechanisms for updating the timing constraints of a net. First, we propose to change the
        static time interval of a transition each time it is newly enabled; in this case the new
        time interval is given as a function of the current marking. Next, we allow to update the
        firing date of a transition when it is persistent, that is when a concurrent transition
        fires. We show how to carry the widely used state class abstraction to this new kind of time
        Petri nets and define a class of nets for which the abstraction is exact. We show the
        usefulness of our approach with two applications: first for scheduling preemptive task, as a
        poor man's substitute for stopwatch, then to model hybrid systems with non trivial
        continuous behavior.</p>
    </abstract>
    <copyright organization="LAAS" />
    <tags>Verification, Time Petri nets, Tina</tags>
    <project>openetcs</project>
  </techreport>

  <inproceedings key="formats2014fickle">
    <authors>
      <author>&lukasz;</author>
      <author>&dalzilio;</author>
      <author>&bernard;</author>
      <author>&francois;</author>
    </authors>
    <title>Time Petri Nets with Dynamic Firing Dates: Semantics and Applications</title>
    <url type="pdf" href="Papers/formatsfickle.pdf" />
    <booktitle>
      <short>FORMATS 2014</short>
      <long>12th International Conference on Formal Modeling and Analysis of Timed Systems</long>
    </booktitle>
    <year>2014</year>
    <month>9</month>
    <volume>8711</volume>
    <pages bgn="85" end="99" />
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <doi>10.1007/978-3-319-10512-3_7</doi>
    <abstract>
      <p>We define an extension of time Petri nets such that the time at which a transition can
        fire, also called its firing date, may be dynamically updated. Our extension provides two
        mechanisms for updating the timing constraints of a net. First, we propose to change the
        static time interval of a transition each time it is newly enabled; in this case the new
        time interval is given as a function of the current marking. Next, we allow to update the
        firing date of a transition when it is persistent, that is when a concurrent transition
        fires. We show how to carry the widely used state class abstraction to this new kind of time
        Petri nets and define a class of nets for which the abstraction is exact. We show the
        usefulness of our approach with two applications: first for scheduling preemptive task, as a
        poor man’s substitute for stopwatch, then to model hybrid systems with non trivial
        continuous behavior.</p>
    </abstract>
    <copyright organization="Springer" />
    <referto key="fickleRR">An extended version of this paper appears as
      Research Report LAAS N°14148, May 2014.</referto>
    <tags>Verification, Time Petri nets, Tina</tags>
    <project>openetcs</project>
  </inproceedings>

  <techreport key="rtaadlmodelcheck2015">
    <authors>
      <author>&dalzilio;</author>
      <author>&bernard;</author>
      <author>&francois;</author>
      <author>&mamoun;</author>
      <author>&bodeveix;</author>
      <author>
        <name>Verdier</name>
        <forename>Guillaume</forename>
      </author>
    </authors>
    <month>3</month>
    <url type="pdf" href="Papers/rtaadlmodelcheck.pdf" />
    <title>Real-Time Model Checking Support for AADL</title>
    <year>2015</year>
    <hal>01121605</hal>
    <arxiv>1503.00493</arxiv>
    <institution>LAAS</institution>
    <number>15036</number>
    <abstract>
      <p>We describe a model-checking toolchain for the behavioral verification of AADL models that
        takes into account the realtime semantics of the language and that is compatible with the
        AADL Behavioral Annex. We give a high-level view of the tools and transformations involved
        in the verification process and focus on the support offered by our framework for checking
        user-defined properties. We also describe the experimental results obtained on a significant
        avionic demonstrator, that models a network protocol in charge of data communications
        between an airplane and ground stations.</p>
    </abstract>
    <copyright organization="LAAS" />
    <tags>Verification, Architecture Languages</tags>
    <project>openetcs</project>
  </techreport>

  <inproceedings key="ttcs2015probes">
    <authors>
      <author>&dalzilio;</author>
      <author>&bernard;</author>
    </authors>
    <title>Automating the Verification of Realtime Observers using Probes and the Modal mu-calculus</title>
    <url type="pdf" href="Papers/ttcs2015probes.pdf" />
    <booktitle>
      <short>TTCS 2015</short>
      <long>1st IFIP International Conference on Topics in Theoretical Computer Science</long>
    </booktitle>
    <year>2015</year>
    <month>8</month>
    <volume>9541</volume>
    <pages bgn="85" end="99" />
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <doi>10.1007/978-3-319-10512-3_7</doi>
    <abstract>
      <p>A classical method for model-checking timed properties, such as those expressed using timed
        extensions of temporal logic, is to rely on the use of observers. In this context, a major
        problem is to prove the correctness of observers. Essentially, this boils down to proving
        that: (1) every trace that contradicts a property can be detected by the observer; but also
        that (2) the observer is innocuous, meaning that it cannot interfere with the system under
        observation. In this paper, we describe a method for automatically testing the correctness
        of realtime observers. This method is obtained by automating an approach often referred to
        as visual verification, in which the correctness of a system is performed by inspecting a
        graphical representation of its state space. Our approach has been implemented on the tool
        Tina, a model-checking toolbox for Time Petri Net.</p>
    </abstract>
    <copyright organization="Springer" />
    <tags>Verification, Time Petri nets, Tina, Patterns</tags>
    <project>briefcase</project>
  </inproceedings>

  <inproceedings key="waters2015video">
    <authors>
      <author>&dalzilio;</author>
      <author>&bernard;</author>
      <author>&didier;</author>
    </authors>
    <title>Latency Analysis of an Aerial Video Tracking System Using Fiacre and Tina</title>
    <url type="pdf" href="Papers/waters2015video.pdf" />
    <booktitle>
      <short>WATERS 2015</short>
      <long>6th International Workshop on Analysis Tools and Methodologies for Embedded and
        Real-time Systems (FMTV verification challenge)</long>
    </booktitle>
    <year>2015</year>
    <month>7</month>
    <abstract>
      <p>We describe our experience with modeling a video tracking system used to detect and follow
        moving targets from an airplane. We provide a formal model that takes into account the
        real-time properties of the system and use it to compute the worst and best-case end to end
        latency. We also compute a lower bound on the delay between the loss of two frames.</p>
      <p>Our approach is based on the model-checking tool Tina, that provides state-space generation
        and model-checking algorithms for an extension of Time Petri Nets with data and priorities.
        We propose several models divided in two main categories: first Time Petri Net models, which
        are used to study the behavior of the system in the most basic way; then models based on the
        Fiacre specification language, where we take benefit of richer data structures to directly
        model the buffering of video information and the use of an unbounded number of frame
        identifiers.</p>
    </abstract>
    <tags>Verification, Use Case, Tina, Fiacre</tags>
    <project>briefcase</project>
  </inproceedings>

  <techreport key="ffa2015">
    <authors>
      <author>&dalzilio;</author>
      <author>
        <name>Raclet</name>
        <forename>Jean-Baptiste</forename>
      </author>
      <author>
        <name>Avellaneda</name>
        <forename>Florent</forename>
      </author>
    </authors>
    <month>10</month>
    <url type="pdf" href="Papers/ffa2015.pdf" />
    <title>On the Complexity of Flanked Finite State Automata</title>
    <year>2015</year>
    <hal>01202702</hal>
    <arxiv>1509.06501</arxiv>
    <institution>LAAS</institution>
    <number>15357</number>
    <abstract>
      <p>We define a new subclass of nondeterministic finite automata for prefix-closed languages
        called Flanked Finite Automata (FFA). We show that this class enjoys good complexity
        properties while preserving the succinctness of nondeterministic automata. In particular, we
        show that the universality problem for FFA is in linear time and that language inclusion can
        be checked in polynomial time. A useful application of FFA is to provide an efficient way to
        compute the quotient and inclusion of regular languages without the need to use the powerset
        construction. These operations are the building blocks of several verification algorithms.</p>
    </abstract>
    <copyright organization="LAAS" />
    <tags>Verification, Automata</tags>
    <project>briefcase</project>
  </techreport>

  <inproceedings key="sac2015symmetry">
    <authors>
      <author>&bourdil;</author>
      <author>&bernard;</author>
      <author>&dalzilio;</author>
      <author>&francois;</author>
    </authors>
    <title>Symmetry reduced state classes for time petri nets</title>
    <url type="pdf" href="Papers/sac2015symmetry.pdf" />
    <booktitle>
      <short>SAC 2015</short>
      <long>30th Annual ACM Symposium on Applied Computing</long>
    </booktitle>
    <year>2015</year>
    <month>4</month>
    <pages bgn="1751" end="1758 " />
    <publisher>ACM</publisher>
    <doi>10.1145/2695664.2695803</doi>
    <abstract>
      <p>We propose a method to exploit the symmetries of a realtime system represented by a Time
        Petri net for its verification by model-checking. The method handles both markings and
        timing constraints; it can be used in conjunction with the widely used state classes
        abstraction. The approach has been implemented and experiments are reported.</p>
    </abstract>
    <copyright organization="ACM" />
    <referto key="scp2016symmetries">An extended version appears in
      Science of Computer Programming 132(2):209-225, Aug 2016.</referto>
    <tags>Verification, Time Petri nets, Tina</tags>
  </inproceedings>

  <article key="scp2016symmetries">
    <authors>
      <author>&bourdil;</author>
      <author>&bernard;</author>
      <author>&dalzilio;</author>
      <author>&francois;</author>
    </authors>
    <title>Symmetry reduction for time Petri net state classes</title>
    <journal>Science of Computer Programming</journal>
    <volume>132</volume>
    <number>2</number>
    <pages bgn="209" end="225" />
    <url type="pdf" href="Papers/scp2016symmetries.pdf" />
    <year>2016</year>
    <month>8</month>
    <hal>01561994</hal>
    <doi>10.1016/j.scico.2016.08.008</doi>
    <abstract>
      <p>We propose a method to exploit the symmetries of a real-time system represented by a Time
        Petri net for its verification by model-checking. The method handles both markings and
        timing constraints; it can be used in conjunction with the widely used state classes
        abstraction, a construction providing a finite representation of the behavior of a Time
        Petri net preserving its markings and traces. The approach has been implemented and
        experiments are reported.</p>
    </abstract>
    <tags>Verification, Time Petri nets, Tina</tags>
    <!-- <referby key="sac2015symmetry" /> -->
  </article>

  <inproceedings key="afadl2016mcse">
    <authors>
      <author>&hladik;</author>
      <author>&dalzilio;</author>
      <author>
        <name>Pasquier</name>
        <forename>Olivier</forename>
      </author>
      <author>
        <name>Pillement</name>
        <forename>Sébastien</forename>
      </author>
      <author>&bernard;</author>
    </authors>
    <title>Outillage pour la modélisation, la vérification et la génération d'applications
      temporisées et embarquées</title>
    <url type="pdf" href="Papers/afadl2016mcse.pdf" />
    <booktitle>
      <short>AFADL 2016</short>
      <long>15èmes journées Approches Formelles dans l'Assistance au Développement de Logiciels </long>
    </booktitle>
    <year>2016</year>
    <month>6</month>
    <hal>01331726</hal>
    <abstract>
      <p>Cet article présente un travail en cours pour mettre en place une chaîne d'outils dédiée à
        la conception, la vérification et l'exécution de systèmes embarqués temps réel. Ce travail
        se base sur la méthode MCSE et les modèles qu'elle préconise pour la description
        d'applications. Une traduction du modèle dans le langage formel Fiacre est appliquée pour
        ensuite vérifier le système à l'aide du model-checker Tina. Afin de faciliter cette analyse
        et la génération d'un exécutif, la notion de Logical Execution Time est utilisée pour
        décrire le comportement tem-porel. Nous présentons ces différentes méthodes et outils avant
        d'exposer l'état d'avancement des différents composants de la chaîne.</p>
    </abstract>
    <tags>Verification, Architecture Languages, Fiacre</tags>
  </inproceedings>

  <inproceedings key="atva2016flanked">
    <authors>
      <author>&dalzilio;</author>
      <author>&avellaneda;</author>
      <author>&raclet;</author>
    </authors>
    <title>Solving Language Equations Using Flanked Automata</title>
    <url type="pdf" href="Papers/atva2016flanked.pdf" />
    <booktitle>
      <short>ATVA 2016</short>
      <long>14th International Symposium on Automated Technology for Verification and Analysis</long>
    </booktitle>
    <year>2016</year>
    <month>10</month>
    <volume>9938</volume>
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <pages bgn="106" end="121" />
    <doi>10.1007/978-3-319-46520-3_7</doi>
    <hal>01202702</hal>
    <project>briefcase</project>
    <abstract>
      <p>We define a new subclass of nondeterministic finite automata for prefix-closed languages
        called Flanked Finite Automata (FFA). Our motivation is to provide an efficient way to
        compute the quotient and inclusion of regular languages without the need to determinize the
        underlying automata. These operations are the building blocks of several verification
        algorithms that can be interpreted as language equation solving problems. We provide a
        construction for computing a FFA accepting the quotient and product of languages that is
        compositional and that does not incur an exponential blow up in size. This makes flanked
        au-tomata a good candidate as a formalism for compositional design and verification of
        systems.</p>
    </abstract>
    <copyright organization="Springer" />
    <tags>Verification, Automata</tags>
    <project>briefcase</project>
  </inproceedings>

  <techreport key="RR2016confidence">
    <authors>
      <author>&dalzilio;</author>
      <author>&bourdil;</author>
      <author>&jenn;</author>
    </authors>
    <title>Integrating Model Checking in an Industrial Verification Process: a Structuring Approach</title>
    <project>ingequip</project>
    <year>2016</year>
    <institution>LAAS</institution>
    <number>16115</number>
    <url type="pdf" href="Papers/RR2016confidence.pdf" />
    <month>7</month>
    <hal>01341701</hal>
    <abstract>
      <p>An obstacle to the adoption of model-checking in large projects is a lack of guidelines on
        how to integrate formal methods with existing system engineering practices. In this context,
        a methodology should give answers to several questions: How to manage the models and
        abstractions used to verify a claim? How do we gain confidence on the soundness of these
        models? How can we build a structured argument from the verification results? In this paper
        , we describe a structured approach for managing verification arguments an apply it to check
        a critical function of an autonomous rover.</p>
    </abstract>
    <copyright organization="LAAS" />
    <!-- <referby key="safecomp2016confidence" /> -->
    <tags>Verification, Safety</tags>
    <project>ingequip</project>
  </techreport>

  <inproceedings key="safecomp2016confidence">
    <authors>
      <author>&dalzilio;</author>
      <author>&bourdil;</author>
      <author>&jenn;</author>
    </authors>
    <title>Building Confidence on Formal Verification Models</title>
    <url type="pdf" href="Papers/safecomp2016confidence.pdf" />
    <booktitle>
      <short>SAFECOMP 2016</short>
      <long>Fast Abstracts at International Conference on Computer Safety, Reliability, and Security</long>
    </booktitle>
    <year>2016</year>
    <month>9</month>
    <hal>01369144</hal>
    <project>ingequip</project>
    <abstract>
      <p>A problem hindering the adoption of formal methods in the industry is how to integrate the
        models and results used during formal verification with existing processes. Indeed, formal
        verification is a complex process involving multiple methods, models, level of formality,
        ... If we want to use formal verification results in an assurance case, it is therefore
        necessary to build confidence on this process. The integration of formal methods raises
        particular problems like, for instance, with the construction of the verification models: a
        model may not preserve all properties of the system to be verified; it may only cover a
        subset of these properties; or it may be intractable. In practice, this means that the
        verification process involves a collection of models whose soundness (with the original
        system design, but also between each others) shall be justified. Furthermore, formal
        techniques are usually restricted in terms of the set of properties that can be checked. It
        is therefore necessary to justify (and trace back) that these restrictions are consistent
        with the hypotheses made about the system, its application and its environment. This short
        abstract gives an overview of a methodology for building verification arguments, that is
        convincing arguments that a system design complies with a set of properties. </p>
    </abstract>
    <referto key="RR2016confidence">An extended version of this paper appears as
      Research Report LAAS N°16115, July 2016.</referto>
    <tags>Verification, Safety</tags>
    <project>ingequip</project>
  </inproceedings>

  <inproceedings key="icfem2016robots">
    <authors>
      <author>&foughali;</author>
      <author>&bernard;</author>
      <author>&dalzilio;</author>
      <author>
        <name>Ingrand</name>
        <forename>Félix</forename>
      </author>
      <author>
        <name>Mallet</name>
        <forename>Anthony</forename>
      </author>
    </authors>
    <title>Model Checking Real-Time Properties on the Functional Layer of Autonomous Robots</title>
    <url type="pdf" href="Papers/icfem2016robots.pdf" />
    <booktitle>
      <short>ICFEM 2016</short>
      <long>18th International Conference on Formal Engineering Methods</long>
    </booktitle>
    <year>2016</year>
    <month>11</month>
    <hal>01346080</hal>
    <doi>10.1007/978-3-319-47846-3_24</doi>
    <volume>10009</volume>
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <pages bgn="383" end="399" />
    <abstract>
      <p>Software is an essential part of robotic systems. As robots and autonomous systems are more
        and more deployed in human environments, we need to use elaborate validation and
        verification techniques in order to gain a higher level of trust in our systems. This
        motivates our determination to apply formal verification methods to robotics software. In
        this paper, we describe our results obtained using model-checking on the functional layer of
        an autonomous robot. We implement an automatic translation from GenoM, a robotics
        model-based software engineering framework, to the formal specification language Fiacre.
        This translation takes into account the semantics of the robotics middleware. TINA, our
        model-checking toolbox, can be used on the synthesized models to prove real-time properties
        of the functional modules implementation on the robot. We illustrate our approach using a
        realistic autonomous navigation example.</p>
    </abstract>
    <tags>Verification, Fiacre, Robotics</tags>
  </inproceedings>

  <inproceedings key="imbsa2017altarica">
    <authors>
      <author>
        <name>Albore</name>
        <forename>Alexandre</forename>
      </author>
      <author>&dalzilio;</author>
      <author>
        <name>Infantes</name>
        <forename>Guillaume</forename>
      </author>
      <author>
        <name>Seguin</name>
        <forename>Christel</forename>
      </author>
      <author>
        <name>Virelizier</name>
        <forename>Pierre</forename>
      </author>
    </authors>
    <title>A Model-Checking Approach to Analyse Temporal Failure Propagation with AltaRica</title>
    <url type="pdf" href="Papers/imbsa2017altarica.pdf" />
    <booktitle>
      <short>IMBSA 2017</short>
      <long>18th International Conference on Formal Engineering Methods</long>
    </booktitle>
    <year>2017</year>
    <month>9</month>
    <hal>01693391</hal>
    <doi>10.1007/978-3-319-64119-5_10</doi>
    <volume>10437</volume>
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <pages bgn="147" end="162" />
    <project>moise</project>
    <abstract>
      <p>The design of complex safety critical systems raises new technical challenges for the
        industry. As systems become more complex—and include more and more interacting functions—it
        becomes harder to evaluate the safety implications of local failures and their possible
        propagation through a whole system. That is all the more true when we add time to the
        problem, that is when we consider the impact of computation times and delays on the
        propagation of failures. We describe an approach that extends models developed for Safety
        Analysis with timing information and provide tools to reason on the correctness of temporal
        safety conditions. Our approach is based on an extension of the AltaRica language where we
        can associate timing constraints with events and relies on a translation into a realtime
        model-checking toolset. We illustrate our method with an example that is representative of
        safety architectures found in critical systems.</p>
    </abstract>
    <tags>Verification, Fiacre, Safety</tags>
    <project>moise</project>
  </inproceedings>

  <inproceedings key="tase2017patterns">
    <authors>
      <author>
        <name>Ge</name>
        <forename>Ning</forename>
      </author>
      <author>&pantel;</author>
      <author>&dalzilio;</author>
    </authors>
    <title>Formal Verification of User-Level Real-Time Property Patterns</title>
    <url type="pdf" href="Papers/tase2017patterns.pdf" />
    <booktitle>
      <short>TASE 2017</short>
      <long>11th International Symposium on Theoretical Aspects of Software Engineering</long>
    </booktitle>
    <year>2017</year>
    <month>9</month>
    <hal>01589479</hal>
    <doi>10.1109/TASE.2017.8285630</doi>
    <publisher>&IEEE;</publisher>
    <abstract>
      <p>To ease the expression of real-time requirements, Dwyer, and then Konrad, studied a large
        collection of existing systems in order to identify a set of real-time property patterns
        covering most of the useful use cases. The goal was to provide a set of reusable patterns
        that system designers can instantiate to express requirements instead of using complex
        temporal logic formulas. A limitation of this approach is that the choice of patterns is
        more oriented towards expressiveness than efficiency; meaning that it does not take into
        account the computational complexity of checking patterns. For this purpose, we define a set
        of verification-dedicated, atomic property patterns for qualitative and quantitative
        real-time requirements. End-user requirements can then be expressed as a composition of
        these patterns using a predefined meta-model and a mapping library. These properties can be
        checked efficiently using a set of elementary observers and a model checking approach.</p>
    </abstract>
    <tags>Verification, Time Petri nets, Patterns</tags>
  </inproceedings>

  <inproceedings key="spin2018counting">
    <authors>
      <author>&bernard;</author>
      <author>&didier;</author>
      <author>&dalzilio;</author>
    </authors>
    <title>Petri Net Reductions for Counting Markings</title>
    <url type="pdf" href="Papers/spin2018counting.pdf" />
    <booktitle>
      <short>SPIN 2018</short>
      <long>International Symposium on Model Checking Software</long>
    </booktitle>
    <year>2018</year>
    <month>6</month>
    <hal>01822078</hal>
    <arxiv>1807.02973</arxiv>
    <doi>10.1007/978-3-319-94111-0_4</doi>
    <volume>10869</volume>
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <pages bgn="65" end="84" />
    <abstract>
      <p>We propose a method to count the number of reachable markings of a Petri net without having
        to enumerate these first. The method relies on a structural reduction system that reduces
        the number of places and transitions of the net in such a way that we can faithfully compute
        the number of reachable markings of the original net from the reduced net and the reduction
        history. The method has been implemented and computing experiments show that reductions are
        effective on a large benchmark of models.</p>
    </abstract>
    <referto key="sttt2019counting">A longer version appears in the
      International Journal on Software Tools for Technology Transfer (STTT),
      April 2019.</referto>
    <tags>Verification, Petri, Tina, Reductions</tags>
  </inproceedings>

  <inproceedings key="ertss2018fdir">
    <authors>
      <author>
        <name>Albore</name>
        <forename>Alexandre</forename>
      </author>
      <author>&dalzilio;</author>
      <author>
        <name>De Roquemaurel</name>
        <forename>Marie</forename>
      </author>
      <author>
        <name>Seguin</name>
        <forename>Christel</forename>
      </author>
      <author>
        <name>Virelizier</name>
        <forename>Pierre</forename>
      </author>
    </authors>
    <title>Timed Formal Model and Verification of Satellite FDIR in Early Design Phase</title>
    <url type="pdf" href="Papers/ertss2018fdir.pdf" />
    <booktitle>
      <short>ERTS 2018</short>
      <long>9th European Congress on Embedded Real Time Software and Systems </long>
    </booktitle>
    <year>2018</year>
    <month>1</month>
    <hal>01709008</hal>
    <project>moise</project>
    <abstract>
      <p>In a previous work, we proposed an extension of the AltaRica language and tools to deal
        with the modelling and analysis of failures propagation in presence of timed and temporal
        constraints. This need is crucial in the space industry, where safety functionalities raise
        new challenges for the early validation of systems during model conception. This paper
        focuses on the application of our approach to the Failure Detection Isolation and Recovery
        (FDIR) mechanisms of the Attitude and Orbit Control System (AOCS) of a satellite. We discuss
        the modelling methodology applied to this system and its properties, as well as the
        tractability of the model-checking analysis.</p>
    </abstract>
    <tags>Verification, Use Case, Fiacre, Safety</tags>
    <project>moise</project>
  </inproceedings>

  <techreport key="RR2018scalian">
    <authors>
      <author>
        <name>Scarduelli</name>
        <forename>Rafael</forename>
      </author>
      <author>&bourdil;</author>
      <author>&dalzilio;</author>
      <author>&didier;</author>
    </authors>
    <title>Time-accurate Middleware for the Virtualization of Communication Protocols</title>
    <project>scalian</project>
    <year>2018</year>
    <institution>LAAS</institution>
    <number>18126</number>
    <hal>01793367</hal>
    <url type="pdf" href="Papers/RR2018scalian.pdf" />
    <month>5</month>
    <arxiv>1805.09256</arxiv>
    <abstract>
      <p>Communication between devices in avionics systems must be predictable and deterministic,
        and data must be delivered reliably. To help the system architects comply with these
        requirements, network protocol standards like ARINC 429 and AFDX were created. Even though
        the behaviour of each component in a network is well defined, it is still necessary to test
        extensively every applications before deployment. But physical test benches used in the
        aircraft development process are complex and expensive platforms. In order to limit the need
        for physical tests, we propose a time-accurate middleware for virtualizing communication
        protocols that can be used to replace physical tests with simulations. We specified three
        formal models of AFDX networks that take into account temporal constraints with different
        levels of precision. We also developed a prototype for a network virtualization middleware
        based on the AFDX protocol specification that provides an easy-to-setup environment for
        testing network configurations. Finally, we used formal models together with virtualization
        in order to define runtime monitors for checking whether the behavior of the middleware is
        time-accurate with respect to a real system.</p>
    </abstract>
    <copyright organization="LAAS" />
    <tags>Verification, Use Case, Fiacre</tags>
  </techreport>

  <inproceedings key="icse2018genom">
    <authors>
      <author>&foughali;</author>
      <author>&bernard;</author>
      <author>&dalzilio;</author>
      <author>&hladik;</author>
      <author>
        <name>Ingrand</name>
        <forename>Félix</forename>
      </author>
      <author>
        <name>Mallet</name>
        <forename>Anthony</forename>
      </author>
    </authors>
    <title>Formal Verification of Complex Robotic Systems on Resource-Constrained Platforms</title>
    <url type="pdf" href="Papers/icse2018genom.pdf" />
    <booktitle>
      <short>FormaliSE</short>
      <long>6th International Conference on Formal Methods in Software Engineering</long>
    </booktitle>
    <year>2018</year>
    <month>6</month>
    <hal>01778960</hal>
    <doi>10.1145/3193992.3193996</doi>
    <publisher>ACM</publisher>
    <pages bgn="2" end="9" />
    <abstract>
      <p>Software constitutes a major part of the development of robotic and autonomous systems and
        is critical to their successful deployment in our everyday life. Robotic software must thus
        run and perform as specified. Since most of these systems are used in a hard real-time
        context, the schedulability of their tasks is a crucial property. In this work, we propose
        to use formal methods to check whether the tasks of a robotic application are schedulable
        with respect to a given hardware platform. For this, we automatically translate functional
        components specified in GenoM into FIACRE, a formal language for timed systems. The
        generated models integrate realistic real-time schedulers based on the FCFS and the SJF
        cooperative policies. We use then the model-checker TINA to assert schedulability
        properties. We carry out experiments on a real robotic system, namely a quadcopter flight
        controller. We demonstrate that, on its actual hardware, schedulability properties can be
        formally expressed and verified. We give examples on how we can check other important
        behavioral and timed properties on the same synthesized models.</p>
    </abstract>
    <tags>Verification, Tina, Robotics</tags>
  </inproceedings>

  <!-- ************************************************************************************** -->
  <!-- ************************************************************************************** -->

  <techreport key="RR2019genom">
    <authors>
      <author>&foughali;</author>
      <author>&dalzilio;</author>
      <author>
        <name>Ingrand</name>
        <forename>Félix</forename>
      </author>
    </authors>
    <title>On the Semantics of the GenoM3 Framework</title>
    <year>2019</year>
    <institution>LAAS</institution>
    <number>19036</number>
    <hal>01992470</hal>
    <url type="pdf" href="Papers/RR2019genom.pdf" />
    <month>1</month>
    <abstract>
      <p>The goal of this document is to add to the efforts toward the long-sought objective of
        secure and safe robots with predictable and a priori known behavior. For this, we give
        operational semantics to GenoM3, a robotic framework, in terms of timed transition systems
        TTS. Then, a mathematically proven translation to timed automata extended with urgencies and
        data DUTA is derived from such semantics. Thus, we provide a mapping from functional
        components to verifiable models. Since TTS and DUTA are at the heart of a large corpus of
        formal verification languages and tools (such as UPPAAL, Fiacre, and RT-BIP), the semantics
        and its translation allow a correct mapping between GenoM3 and such languages/tools. This
        connection can then be automatized thanks to GenoM3 templates.</p>
    </abstract>
    <copyright organization="LAAS" />
    <tags>Verification, Robotics</tags>
  </techreport>

  <inproceedings key="TOOLympics2019">
    <authors>
      <author>
        <name>Amparore</name>
        <forename>Elvio</forename>
      </author>
      <author>&bernard;</author>
      <author>
        <name>Ciardo</name>
        <forename>Gianfranco</forename>
      </author>
      <author>&dalzilio;</author>
      <author>
        <name>Gallà</name>
        <forename>Francesco</forename>
      </author>
      <author>
        <name>Hillah</name>
        <forename>Lom Messan</forename>
      </author>
      <author>
        <name>Hulin-Hubard</name>
        <forename>Francis</forename>
      </author>
      <author>
        <name>Jensen</name>
        <forename>Peter Gjøl</forename>
      </author>
      <author>
        <name>Jezequel</name>
        <forename>Loïg</forename>
      </author>
      <author>
        <name>Kordon</name>
        <forename>Fabrice</forename>
      </author>
      <author>&didier;</author>
      <author>
        <name>Liebke</name>
        <forename>Torsten</forename>
      </author>
      <author>
        <name>Meijer</name>
        <forename>Jeroen</forename>
      </author>
      <author>
        <name>Miner</name>
        <forename>Andrew</forename>
      </author>
      <author>
        <name>Paviot-Adet</name>
        <forename>Emmanuel</forename>
      </author>
      <author>
        <name>Srba</name>
        <forename>Jiří</forename>
      </author>
      <author>
        <name>Thierry-Mieg</name>
        <forename>Yann</forename>
      </author>
      <author>
        <name>van Dijk</name>
        <forename>Tom</forename>
      </author>
      <author>
        <name>Wolf</name>
        <forename>Karsten</forename>
      </author>
    </authors>
    <title>Presentation of the 9th Edition of the Model Checking Contest</title>
    <url type="pdf" href="Papers/TOOLympics2019.pdf" />
    <booktitle>
      <short>TACAS 2019</short>
      <long>Tools and Algorithms for the Construction and Analysis of Systems</long>
    </booktitle>
    <year>2019</year>
    <month>4</month>
    <hal>02094047</hal>
    <doi>10.1007/978-3-030-17502-3_4</doi>
    <volume>11429</volume>
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <abstract>
      <p>The Model Checking Contest (MCC) is an annual competition of software tools for model
        checking. Tools must process an increasing benchmark gathered from the whole community and
        may participate in various examinations: state space generation, computation of global
        properties, computation of some upper bounds in the model, evaluation of reachability
        formulas, evaluation of CTL formulas, and evaluation of LTL formulas. For each examination
        and each model instance, participating tools are provided with up to 3600s and 16 gigabyte
        of memory. Then, tool answers are analyzed and confronted to the results produced by other
        competing tools to detect diverging answers (which are quite rare at this stage of the
        competition, and lead to penalties). For each examination, golden, silver, and bronze medals
        are attributed to the three best tools. CPU usage and memory consumption are reported, which
        is also valuable information for tool developers.</p>
    </abstract>
    <tags>Verification, Petri, Tina</tags>
  </inproceedings>

  <article key="sttt2019counting">
    <authors>
      <author>&bernard;</author>
      <author>&didier;</author>
      <author>&dalzilio;</author>
    </authors>
    <title>Counting Petri net markings from reduction equations</title>
    <journal>International Journal on Software Tools for Technology Transfer (STTT)</journal>
    <pages bgn="1" end="19" />
    <year>2019</year>
    <month>4</month>
    <hal>02125337</hal>
    <doi>10.1007/s10009-019-00519-1</doi>
    <abstract>
      <p>We propose a method to count the number of reachable markings of a Petri net without having
        to enumerate these first. The method relies on a structural reduction system that reduces
        the number of places and transitions of the net in such a way that we can faithfully compute
        the number of reachable markings of the original net from the reduced net and the reduction
        history. The method has been implemented, and computing experiments show that reductions are
        effective on a large benchmark of models.</p>
    </abstract>
    <tags>Verification, Reductions, Petri, Tina</tags>
  </article>

  <inproceedings key="formats2019twina">
    <authors>
      <author>
        <name>Lubat</name>
        <forename>Éric</forename>
      </author>
      <author>&dalzilio;</author>
      <author>&didier;</author>
      <author>
        <name>Pencolé</name>
        <forename>Yannick</forename>
      </author>
      <author>
        <name>Subias</name>
        <forename>Audine</forename>
      </author>
    </authors>
    <title>A State Class Construction for Computing the Intersection of Time Petri Nets Languages</title>
    <url type="pdf" href="Papers/formats2019twina.pdf" />
    <booktitle>
      <short>FORMATS 2019</short>
      <long>17th International Conference on Formal Modeling and Analysis of Timed Systems</long>
    </booktitle>
    <year>2019</year>
    <month>8</month>
    <hal>02263832</hal>
    <doi>10.1007/978-3-030-29662-9_5</doi>
    <volume>11750</volume>
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <pages bgn="79" end="95" />
    <abstract>
      <p>We propose a new method for computing the language intersection of two Time Petri nets
        (TPN); that is the sequence of labels in timed traces common to the execution of two TPN.
        Our approach is based on a new product construction between nets and relies on the State
        Class construction, a widely used method for checking the behaviour of TPN. We prove that
        this new construct does not add additional expressive power, and yet that it can lead to
        very concise representation of the result. We have implemented our approach in a new tool,
        called Twina. We report on some experimental results obtained with this tool and show how to
        apply our approach on two interesting problems: first, to define an equivalent of the
        twin-plant diagnosability methods for TPN; then as a way to check timed properties without
        interfering with a system.</p>
    </abstract>
    <tags>Verification, Tools, Time Petri nets, Twina, Diagnosability</tags>
  </inproceedings>

  <inproceedings key="movep2020twina">
    <authors>
      <author>
        <name>Lubat</name>
        <forename>Éric</forename>
      </author>
      <author>&dalzilio;</author>
    </authors>
    <title>A Short Overview on Diagnosability of Patterns in Timed Petri Net</title>
    <url type="pdf" href="Papers/movep2020twina.pdf" />
    <booktitle>
      <short>MOVEP 2020</short>
      <long>14th Summer School on Modelling and Verification of Parallel Processes</long>
    </booktitle>
    <year>2020</year>
    <month>6</month>
    <hal>02899522</hal>
    <abstract>
      <p>Diagnosability is a basic property of Discrete Event Systems that relates to the
        observability of concealed events. Basically, it means that every failure (a distinct
        instance of unobservable event) can be eventually detected after a finite number of
        observations. In this work, we are interested by the diagnosability of systems modelled
        using labelled Time Petri nets (TPN), an extension of Petri nets in which we can associate
        timing constraints to transitions. This means that we take into account the date at which
        events are observed and that we want to detect failures in a bounded time. We are also
        interested by the detection of patterns of events (sequence of observable events that are
        part of some given regular language) instead of the occurrence of a single fault.</p>
    </abstract>
    <tags>Verification, Time Petri nets, Twina, Diagnosability</tags>
  </inproceedings>

  <inproceedings key="petri2020mcc">
    <authors>
      <author>&dalzilio;</author>
    </authors>
    <title>MCC: a Tool for Unfolding Colored Petri Nets in PNML Format</title>
    <url type="pdf" href="Papers/petri2020mcc.pdf" />
    <booktitle>
      <short>ICATPN 2020</short>
      <long>41st International Conference on Application and Theory of Petri Nets and Concurrency</long>
    </booktitle>
    <year>2020</year>
    <month>6</month>
    <hal>02511881</hal>
    <arxiv>2003.09134</arxiv>
    <doi>10.1007/978-3-030-51831-8_23</doi>
    <volume>12152</volume>
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <pages bgn="426" end="435" />
    <note>This paper won best teaser video award and an accessit to the tool demonstration video
      award.</note>
    <abstract>
      <p>MCC is a tool designed for a very specific task: to transform the models of High-Level
        Petri nets, given in the PNML syntax, into equivalent Place/Transition nets. The name of the
        tool derives from the annual Model-Checking Contest, a competition of model-checking tools
        that provides a large and diverse collection of PNML models. This choice in naming serves to
        underline the main focus of the tool, which is to provide an open and efficient solution
        that lowers the access cost for developers wanting to engage in this competition. We
        describe the architecture and functionalities of our tool and show how it compares with
        other existing solutions. Despite the fact that the problem we target is abundantly covered
        in the literature, we show that it is still possible to innovate. To substantiate this
        assertion, we put a particular emphasis on two distinctive features of MCC that have proved
        useful when dealing with some of the most challenging colored models in the contest, namely
        the use of a restricted notion of higher-order invariant, and the support of a Petri net
        scripting language.</p>
    </abstract>
    <tags>Verification, Tools, Petri, mcc</tags>
  </inproceedings>

  <inproceedings key="ertss2020satellite">
    <authors>
      <author>
        <name>Mussot</name>
        <forename>Vincent</forename>
      </author>
      <author>&dalzilio;</author>
      <author>
        <name>Correnson</name>
        <forename>Loïc</forename>
      </author>
      <author>
        <name>Rainjonneau</name>
        <forename>Serge</forename>
      </author>
      <author>
        <name>Bardout</name>
        <forename>Yves</forename>
      </author>
      <author>
        <name>Scano</name>
        <forename>Grégoire</forename>
      </author>
    </authors>
    <title>Formal Approach for the Verification of Onboard Autonomous Functions in Observation
      Satellites</title>
    <url type="pdf" href="Papers/ertss2020satellite.pdf" />
    <booktitle>
      <short>ERTSS 2020</short>
      <long>10th International Congress and Exhibition on Embedded Real-Time Software and Systems</long>
    </booktitle>
    <year>2020</year>
    <month>1</month>
    <hal>02462058</hal>
    <arxiv>2001.11875</arxiv>
    <note>Best Paper Awards in the category Autonomous and Connected Systems</note>
    <abstract>
      <p>We propose a new approach for modelling the functional behaviour of an Earth observation
        satellite. We leverage this approach in order to develop a safety critical software, a
        "telecommand verifier", that is in charge of checking onboard whether a sequence of
        instructions is safe for execution. This new service is needed in order to add more autonomy
        to satellites. To do so, we propose a new Domain Specific Modelling Language and the
        toolchain required for integration into an embedded software. This framework is based on the
        composition of deterministic finite state machines with safety conditions, timeouts, and
        transitions that accept durations as a parameter. It is able to generate code in the
        synchronous programming language Lustre from a high-level specification of the satellite.
        This gives a formal way to derive an event-based algorithm simulating the execution of
        telecommand sequence and, thereupon, a provably correct onboard verifier.</p>
    </abstract>
    <copyright organization="LAAS" />
    <tags>Verification, Space</tags>
    <project>topcased</project>
  </inproceedings>

  <unpublished key="RR2020ssplace">
    <authors>
      <author>&hujsa;</author>
      <author>&bernard;</author>
      <author>&dalzilio;</author>
      <author>&didier;</author>
    </authors>
    <title>On the Petri Nets with a Single Shared Place and Beyond</title>
    <year>2020</year>
    <arxiv>2005.04818</arxiv>
    <month>5</month>
    <abstract>
      <p>Petri nets proved useful to describe various real-world systems, but many of their
        properties are very hard to check. To alleviate this difficulty, subclasses are often
        considered. The class of weighted marked graphs with relaxed place constraint (WMG=&lt; for
        short), in which each place has at most one input and one output, and the larger class of
        choice-free (CF) nets, in which each place has at most one output, have been extensively
        studied to this end, with various applications. In this work, we develop new properties
        related to the fundamental and intractable problems of reachability, liveness and
        reversibility in weighted Petri nets. We focus mainly on the homogeneous Petri nets with a
        single shared place (H1S nets for short), which extend the expressiveness of CF nets by
        allowing one shared place (i.e. a place with at least two outputs and possibly several
        inputs) under the homogeneity constraint (i.e. all the output weights of the shared place
        are equal). Indeed, this simple generalization already yields new challenging problems and
        is expressive enough for modeling existing use-cases, justifying a dedicated study. One of
        our central results is the first characterization of liveness in a subclass of H1S nets more
        expressive than WMG=&lt; that is expressed by the infeasibility of an integer linear program
        (ILP) of polynomial size. This trims down the complexity to co-NP, contrasting with the
        known EXPSPACE-hardness of liveness in the more general case of weighted Petri nets. In the
        same subclass, we obtain a new reachability property related to the live markings, which is
        a variant of the well-known Keller's theorem. Another central result is a new reversibility
        characterization for the live H1S class, simplifying its checking. Finally, we apply our
        results to use-cases, highlight their scalability and discuss their extensibility to more
        expressive classes.</p>
    </abstract>
    <copyright organization="LAAS" />
    <tags>Verification, Concurrency, Petri</tags>
  </unpublished>

  <unpublished key="RR2020preqr">
    <authors>
      <author>&hujsa;</author>
      <author>&bernard;</author>
      <author>&dalzilio;</author>
      <author>&didier;</author>
    </authors>
    <title>Checking marking reachability with the state equation in Petri net subclasses</title>
    <year>2020</year>
    <arxiv>2006.05600</arxiv>
    <month>6</month>
    <abstract>
      <p>Although decidable, the marking reachability problem for Petri nets is well-known to be
        intractable in general, and a non-elementary lower bound has been recently uncovered. In
        order to alleviate this difficulty, various structural and behavioral restrictions have been
        considered, allowing to relate reachability to properties that are easier to check. For a
        given initial marking, the set of potentially reachable markings is described by the state
        equation solutions and over-approximates the set of reachable markings.</p>

      <p>In this paper, we delineate several subclasses of weighted Petri nets in which the set of
        reachable markings equals the set of potentially reachable ones, a property we call the PR-R
        equality. When fulfilled, this property allows to use linear algebra to answer the
        reachability questions, avoiding a brute-force analysis of the state space. Notably, we
        provide conditions under which this equality holds in classes much more expressive than
        marked graphs, adding places with several ingoing and outgoing transitions, which allows to
        model real applications with shared buffers. To achieve it, we investigate the relationship
        between liveness, reversibility, boundedness and potential reachability in Petri nets. We
        also show that this equality does not hold in classes with close modeling capability when
        the conditions are relaxed.</p>
    </abstract>
    <copyright organization="LAAS" />
    <tags>Verification, Concurrency, Petri</tags>
  </unpublished>

  <inproceedings key="cdc2020diag">
    <authors>
      <author>
        <name>Lubat</name>
        <forename>Éric</forename>
      </author>
      <author>&dalzilio;</author>
      <author>&didier;</author>
      <author>
        <name>Pencolé</name>
        <forename>Yannick</forename>
      </author>
      <author>
        <name>Subias</name>
        <forename>Audine</forename>
      </author>
    </authors>
    <title>A New Product Construction for the Diagnosability of Patterns in Time Petri Net</title>
    <url type="pdf" href="Papers/cdc2020diag.pdf" />
    <booktitle>
      <short>CDC 2020</short>
      <long>59th IEEE Conference on Decision and Control</long>
    </booktitle>
    <year>2020</year>
    <month>12</month>
    <publisher>&IEEE;</publisher>
    <doi>10.1109/CDC42340.2020.9303826</doi>
    <abstract>
      <p>We propose a method to decide the diagnosability of patterns in labeled Time Petri nets
        (TPN) that gracefully extends a classic approach for the diagnosability of single faults.
        Our approach is based on a new technique for computing the language intersection of TPN and
        on an associated extension of the State Class Graph construction. Our approach has been
        implemented and we report on some experimental results.</p>
    </abstract>
    <tags>Verification, Twina, Time Petri nets, Diagnosability</tags>
  </inproceedings>

  <inproceedings key="spin2021kong">
    <authors>
      <author>&namat;</author>
      <author>&dalzilio;</author>
      <author>&didier;</author>
    </authors>
    <title>Accelerating the Computation of Dead and Concurrent Places Using Reductions</title>
    <url type="pdf" href="Papers/spin2021kong.pdf" />
    <booktitle>
      <short>SPIN 2021</short>
      <long>International Symposium on Model Checking Software</long>
    </booktitle>
    <year>2021</year>
    <month>6</month>
    <hal>03268388</hal>
    <doi>10.1007/978-3-030-84629-9_3</doi>
    <arxiv>2106.12813</arxiv>
    <volume>12864</volume>
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <pages bgn="45" end="62" />
    <referto key="ijsttt2023poly">An extended version of this paper appears in
      _International Journal on Software Tools for Technology Transfer_ (STTT) 25,
      dec 2023.</referto>
    <abstract>
      <p>We propose a new method for accelerating the computation of a concurrency relation, that is
        all pairs of places in a Petri net that can be marked together. Our approach relies on a
        state space abstraction, that involves a mix between structural reductions and linear
        algebra, and a new data-structure that is specifically designed for our task. Our algorithms
        are implemented in a tool, called Kong, that we test on a large collection of models used
        during the 2020 edition of the Model Checking Contest. Our experiments show that the
        approach works well, even when a moderate amount of reductions applies.</p>
    </abstract>
    <tags>Verification, Petri, Reductions, Tools, Kong</tags>
  </inproceedings>

  <article key="ijsttt2023poly">
    <authors>
      <author>&namat;</author>
      <author>&dalzilio;</author>
      <author>&didier;</author>
    </authors>
    <title>Leveraging polyhedral reductions for solving Petri net reachability problems</title>
    <journal>International Journal on Software Tools for Technology Transfer</journal>
    <year>2023</year>
    <volume>25</volume>
    <month>12</month>
    <hal>03973463</hal>
    <doi>10.1007/s10009-022-00694-8</doi>
    <referto key="spin2021kong">This is the extended version of a paper
      presented at SPIN 2021 — International Symposium on Model Checking
      Software, jun 2021.</referto>
    <abstract>
      <p>We propose a new method that takes advantage of structural reductions to accelerate the
        verification of reachability properties on Petri nets. Our approach relies on a state space
        abstraction, called polyhedral abstraction, which involves a combination between structural
        reductions and sets of linear arithmetic constraints between the marking of places. We
        propose a new data structure, called a Token Flow Graph (TFG), that captures the particular
        structure of constraints occurring in polyhedral abstractions. We leverage TFGs to
        efficiently solve two reachability problems: first to check the reachability of a given
        marking and then to compute the concurrency relation of a net, that is, all pairs of places
        that can be marked together in some reachable marking. Our algorithms are implemented in a
        tool, called Kong, that we evaluate on a large collection of models used during the 2020
        edition of the Model Checking Contest. Our experiments show that the approach works well,
        even when a moderate amount of reductions applies.</p>
    </abstract>
    <tags>Verification, Petri, Reductions, Tools, Kong</tags>
  </article>

  <inproceedings key="petri2021smpt">
    <authors>
      <author>&namat;</author>
      <author>&dalzilio;</author>
      <author>&bernard;</author>
    </authors>
    <title>On the Combination of Polyhedral Abstraction and SMT-Based Model Checking for Petri Nets</title>
    <url type="pdf" href="Papers/petri2021smpt.pdf" />
    <booktitle>
      <short>ICATPN 2021</short>
      <long>42nd International Conference on Application and Theory of Petri Nets and Concurrency</long>
    </booktitle>
    <year>2021</year>
    <month>6</month>
    <hal>03202111</hal>
    <arxiv>2104.09850 </arxiv>
    <doi>10.1007/978-3-030-76983-3_9</doi>
    <volume>12734</volume>
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <pages bgn="164" end="185" />
    <note>This paper won best teaser video award.</note>
    <referto key="fi2022polyhedral">An extended version of this paper appears in
      _Fundamenta Informaticae_, 2022, 187 (2-4).</referto>
    <abstract>
      <p>We define a method for taking advantage of net reductions in combination with a SMT-based
        model checker. We prove the correctness of this method using a new notion of equivalence
        between nets that we call polyhedral abstraction. Our approach has been implemented in a
        tool, named SMPT, that provides two main procedures: Bounded Model Checking (BMC) and
        Property Directed Reachability (PDR). Each procedure has been adapted in order to use
        reductions and to work with arbitrary Petri nets. We tested SMPT on a large collection of
        queries used during the 2020 edition of the Model Checking Contest. Our experimental results
        show that our approach works well, even when we only have a moderate amount of reductions. </p>
    </abstract>
    <tags>Verification, Tools, SMPT, Reductions, Petri</tags>
  </inproceedings>

  <article key="scp2021rtmobs">
    <authors>
      <author>
        <name>Ge</name>
        <forename>Ning</forename>
      </author>
      <author>&dalzilio;</author>
      <author>
        <name>Liu</name>
        <forename>Hongyu</forename>
      </author>
      <author>
        <name>Zhang</name>
        <forename>Li</forename>
      </author>
      <author>
        <name>Zhang</name>
        <forename>Lianyi</forename>
      </author>
    </authors>
    <title>RT-MOBS: A compositional observer semantics of time Petri net for real-time property
      specification language based on μ-calculus</title>
    <journal>Science of Computer Programming</journal>
    <year>2021</year>
    <volume>206</volume>
    <month>4</month>
    <doi>10.1016/j.scico.2021.102624</doi>
    <abstract>
      <p>We define a new verification method, called RT-MOBS, for checking real-time requirements
        based on Time Petri nets (TPN). Our approach supports requirements specified using a very
        expressive pattern language, the Property Specification Language (PSL) of Autili, Grusnke et
        al., and relies on marking observers' verification. RT-MOBS has many distinctive features,
        such as a focus on performances, a compositional method for deriving the observer and the
        target property directly from the structure of the specification pattern, and the ability to
        deal with the whole real-time fragment of PSL. We demonstrate the effectiveness of our
        approach from three industrial use cases: a mobile ad-hoc network system; the model of a
        flight management system, which is realistic with respect to the industry use during the
        architecture evaluation phase; and a model of an order to cash smart contract. Our
        experimental results show that we can achieve performances that are several orders of
        magnitude better than with methods based on an interpretation of patterns into Linear
        Temporal Logic (LTL) formulas.</p>
    </abstract>
    <tags>Verification, Patterns, Time Petri nets</tags>
  </article>

  <article key="jss2021hippo">
    <authors>
      <author>&hladik;</author>
      <author>
        <name>Ingrand</name>
        <forename>Félix</forename>
      </author>
      <author>&dalzilio;</author>
      <author>
        <name>Tekin</name>
        <forename>Reyyan</forename>
      </author>
    </authors>
    <title>Hippo: A formal-model execution engine to control and verify critical real-time systems</title>
    <journal>Journal of Systems and Software</journal>
    <year>2021</year>
    <volume>181</volume>
    <month>11</month>
    <doi>10.1016/j.jss.2021.111033</doi>
    <abstract>
      <p>The design of embedded real-time systems requires specific toolchains to guarantee time
        constraints and safe behavior. These tools and their artifacts need to be managed in a
        coherent way all along the design process and need to address timing constraints and
        execution semantic in a holistic way during the system’s modeling, verification, and
        implementation phases. However, modeling languages used by these tools do not always share a
        common semantic. This can introduce a dangerous gap between what designers want to express,
        what is verified and the behavior of the final executable code. In order to address this
        problem, we propose a new toolchain, called Hippo, that integrates tools for design,
        verification and execution built around a common formalism.</p>
    </abstract>
    <tags>Verification, Tools, Robotics, Hippo</tags>
  </article>

  <inproceedings key="tacas2022pdr">
    <authors>
      <author>&namat;</author>
      <author>&dalzilio;</author>
      <author>&hujsa;</author>
    </authors>
    <title>Property Directed Reachability for Generalized Petri Nets</title>
    <url type="pdf" href="Papers/tacas2022pdr.pdf" />
    <booktitle>
      <short>TACAS 2022</short>
      <long>International Conference on Tools and Algorithms for the Construction and Analysis of
        Systems</long>
    </booktitle>
    <year>2022</year>
    <month>3</month>
    <hal>03545594</hal>
    <doi>10.1007/978-3-030-99524-9_28</doi>
    <volume>13243</volume>
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <pages bgn="505" end="523" />
    <abstract>
      <p>We propose a semi-decision procedure for checking generalized reachability properties, on
        generalized Petri nets, that is based on the Property Directed Reachability (PDR) method. We
        actually define three different versions, that vary depending on the method used for
        abstracting possible witnesses, and that are able to handle problems of increasing
        difficulty. We have implemented our methods in a model-checker called SMPT and give
        empirical evidences that our approach can handle problems that are difficult or impossible
        to check with current state of the art tools.</p>
    </abstract>
    <tags>Verification, Tools, SMPT, Petri, Reductions</tags>
  </inproceedings>

  <article key="fi2022polyhedral">
    <authors>
      <author>&namat;</author>
      <author>&bernard;</author>
      <author>&dalzilio;</author>
    </authors>
    <title>A Polyhedral Abstraction for Petri nets and its Application to SMT-Based Model Checking</title>
    <journal>Fundamenta Informaticae</journal>
    <year>2022</year>
    <volume>187</volume>
    <number>2-4</number>
    <month>10</month>
    <hal>03455697</hal>
    <doi>10.3233/FI-222134</doi>
    <referto key="petri2021smpt">This is the extended version of a paper
      presented at the 42nd International Conference on Application and Theory of
      Petri Nets and Concurrency.</referto>
    <abstract>
      <p>We define a new method for taking advantage of net reductions in combination with a
        SMT-based model checker. Our approach consists in transforming a reachability problem about
        some Petri net, into the verification of an updated reachability property on a reduced
        version of this net. This method relies on a new state space abstraction based on systems of
        constraints, called polyhedral abstraction. We prove the correctness of this method using a
        new notion of equivalence between nets. We provide a complete framework to define and check
        the correctness of equivalence judgements; prove that this relation is a congruence; and
        give examples of basic equivalence relations that derive from structural reductions. Our
        approach has been implemented in a tool, named SMPT, that provides two main procedures:
        Bounded Model Checking (BMC) and Property Directed Reachability (PDR). Each procedure has
        been adapted in order to use reductions and to work with arbitrary Petri nets. We tested
        SMPT on a large collection of queries used in the Model Checking Contest. Our experimental
        results show that our approach works well, even when we only have a moderate amount of
        reductions.</p>
    </abstract>
    <tags>Verification, Petri, Reductions</tags>
  </article>

  <inproceedings key="poster2023polyhedral">
    <authors>
      <author>&namat;</author>
      <author>&bernard;</author>
      <author>&dalzilio;</author>
      <author>&didier;</author>
    </authors>
    <title>Polyhedral Reductions for Petri nets (Poster)</title>
    <note>Poster presentation</note>
    <booktitle>
      <short>MSR 2023</short>
      <long>Modélisation des Systèmes Réactifs</long>
    </booktitle>
    <year>2023</year>
    <month>11</month>
    <hal>04355257</hal>
    <abstract>
      <p>Polyhedral equivalence defines a linear dependence relation (E) between the reachable
        markings of two nets; where E is a Presburger formula, or a system of linear Diophantine
        equations. This equivalence, denoted (N1, m1) ≡ (N2, m2), preserves enough information in E
        so that we can rebuild the state space of N1 knowing only the one of N2.</p>
    </abstract>
    <copyright organization="LAAS" />
    <tags>Verification, Petri, Reductions</tags>
  </inproceedings>

  <inproceedings key="fm2023smpt">
    <authors>
      <author>&namat;</author>
      <author>&dalzilio;</author>
    </authors>
    <title>SMPT: A Testbed for Reachability Methods in Generalized Petri Nets</title>
    <booktitle>
      <short>FM 2023</short>
      <long>25th International Symposium on Formal Methods</long>
    </booktitle>
    <year>2023</year>
    <month>3</month>
    <hal>04007410</hal>
    <doi>10.1007/978-3-031-27481-7_25</doi>
    <volume>14000</volume>
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <pages bgn="445" end="453" />
    <abstract>
      <p>SMPT (for Satisfiability Modulo Petri Net) is a model checker for reachability problems in
        Petri nets. It started as a portfolio of methods to experiment with symbolic model checking,
        and was designed to be easily extended. Some distinctive features are its ability to benefit
        from structural reductions and to generate verdict certificates. Our tool is quite mature
        and performed well compared to other state-of-the-art tools in the Model Checking Contest.</p>
    </abstract>
    <tags>Verification, Petri, Tools, SMPT, Reductions</tags>
  </inproceedings>

  <inproceedings key="petri2023autpolyprove">
    <authors>
      <author>&namat;</author>
      <author>&dalzilio;</author>
      <author>&didier;</author>
    </authors>
    <title>Automated Polyhedral Abstraction Proving</title>
    <booktitle>
      <short>Petri nets 2023</short>
      <long>44th International Conference on Application and Theory of Petri Nets and Concurrency</long>
    </booktitle>
    <year>2023</year>
    <month>6</month>
    <hal>04115006</hal>
    <doi>10.1007/978-3-031-33620-1_18</doi>
    <volume>13929</volume>
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <pages bgn="324" end="345" />
    <referto key="fi2023polyprove">An extended version of this paper appears in
      _Fundamenta Informaticae_, 192 (3-4), 2024.</referto>
    <abstract>
      <p>We propose an automated procedure to prove polyhedral abstractions for Petri nets.
        Polyhedral abstraction is a new type of state-space equivalence based on the use of linear
        integer constraints. Our approach relies on an encoding into a set of SMT formulas whose
        satisfaction implies that the equivalence holds. The difficulty, in this context, arises
        from the fact that we need to handle infinite-state systems. For completeness, we exploit a
        connection with a class of Petri nets that have Presburger-definable reachability sets. We
        have implemented our procedure, and we illustrate its use on several examples.</p>
    </abstract>
    <tags>Verification, Petri, Tools, Reductron, Reductions</tags>
  </inproceedings>

  <article key="fi2023polyprove">
    <authors>
      <author>&namat;</author>
      <author>&dalzilio;</author>
      <author>&didier;</author>
    </authors>
    <title>On the Complexity of Proving Polyhedral Reductions</title>
    <journal>Fundamenta Informaticae</journal>
    <year>2024</year>
    <volume>192</volume>
    <number>3-4</number>
    <month>9</month>
    <hal>04712076</hal>
    <doi>10.3233/FI-242197</doi>
    <url type="pdf" href="Papers/fi2023polyprove.pdf" />
    <referto key="petri2023autpolyprove">This is the extended version of a paper
      presented at the 44th International Conference on Application and Theory of
      Petri Nets and Concurrency, jun 2023.</referto>
    <abstract>
      <p>We propose an automated procedure to prove polyhedral abstractions (also known as
        polyhedral reductions) for Petri nets. Polyhedral abstraction is a new type of state space
        equivalence, between Petri nets, based on the use of linear integer constraints between the
        marking of places. In addition to defining an automated proof method, this paper aims to
        better characterize polyhedral reductions, and to give an overview of their application to
        reachability problems. Our approach relies on encoding the equivalence problem into a set of
        SMT formulas whose satisfaction implies that the equivalence holds. The difficulty, in this
        context, arises from the fact that we need to handle infinite-state systems. For
        completeness, we exploit a connection with a class of Petri nets, called flat nets, that
        have Presburger-definable reachability sets. We have implemented our procedure, and we
        illustrate its use on several examples.</p>
    </abstract>
    <tags>Verification, Petri, Reductions</tags>
  </article>

  <article key="ecrts2023artifact">
    <authors>
      <author>
        <name>Altmeyer</name>
        <forename>Sebastian</forename>
      </author>
      <author>
        <name>André</name>
        <forename>Étienne</forename>
      </author>
      <author>&dalzilio;</author>
      <author>
        <name>Fejoz</name>
        <forename>Loïc</forename>
      </author>
      <author>
        <name>González Harbour</name>
        <forename>Michael</forename>
      </author>
      <author>
        <name>Graf</name>
        <forename>Susanne</forename>
      </author>
      <author>
        <name>Gutiérrez</name>
        <forename>J. Javier</forename>
      </author>
      <author>
        <name>Henia</name>
        <forename>Rafik</forename>
      </author>
      <author>&didier;</author>
      <author>
        <name>Lipari</name>
        <forename>Giuseppe</forename>
      </author>
      <author>
        <name>Medina</name>
        <forename>Julio</forename>
      </author>
      <author>
        <name>Navet</name>
        <forename>Nicolas</forename>
      </author>
      <author>
        <name>Quinton</name>
        <forename>Sophie</forename>
      </author>
      <author>
        <name>Rivas</name>
        <forename>Juan</forename>
      </author>
      <author>
        <name>Sun</name>
        <forename>Youcheng</forename>
      </author>
    </authors>
    <title>From FMTV to WATERS: Lessons Learned from the First Verification Challenge at ECRTS
      (Artifact)</title>
    <journal> Dagstuhl Artifacts Series (DARTS)</journal>
    <year>2023</year>
    <volume>9</volume>
    <number>1</number>
    <year>2023</year>
    <month>7</month>
    <hal>04254710</hal>
    <doi>10.4230/DARTS.9.1.4</doi>
    <publisher>Schloss Dagstuhl</publisher>
    <referto key="ecrts2023waters">A companion paper, describing the
      challenge and the solutions, appears in ECRTS 2023 — 35th Euromicro
      Conference on Real-Time Systems, 2023.</referto>
    <abstract>
      <p> We propose here solutions to the FMTV 2015 challenge of a distributed video processing
        system using four different formalisms, as well as the description of the challenge itself.
        This artifact contains several solutions to various subchallenges, and instructions and
        scripts to reproduce these results smoothly.</p>
    </abstract>
    <tags>Verification, Time Petri nets, Use Case, Tina, Fiacre</tags>
  </article>

  <inproceedings key="ecrts2023waters">
    <authors>
      <author>
        <name>Altmeyer</name>
        <forename>Sebastian</forename>
      </author>
      <author>
        <name>André</name>
        <forename>Étienne</forename>
      </author>
      <author>&dalzilio;</author>
      <author>
        <name>Fejoz</name>
        <forename>Loïc</forename>
      </author>
      <author>
        <name>González Harbour</name>
        <forename>Michael</forename>
      </author>
      <author>
        <name>Graf</name>
        <forename>Susanne</forename>
      </author>
      <author>
        <name>Gutiérrez</name>
        <forename>J. Javier</forename>
      </author>
      <author>
        <name>Henia</name>
        <forename>Rafik</forename>
      </author>
      <author>&didier;</author>
      <author>
        <name>Lipari</name>
        <forename>Giuseppe</forename>
      </author>
      <author>
        <name>Medina</name>
        <forename>Julio</forename>
      </author>
      <author>
        <name>Navet</name>
        <forename>Nicolas</forename>
      </author>
      <author>
        <name>Quinton</name>
        <forename>Sophie</forename>
      </author>
      <author>
        <name>Rivas</name>
        <forename>Juan</forename>
      </author>
      <author>
        <name>Sun</name>
        <forename>Youcheng</forename>
      </author>
    </authors>
    <title>From FMTV to WATERS: Lessons Learned from the First Verification Challenge at ECRTS
      (Invited Paper)</title>
    <booktitle>
      <short>ECRTS 2023</short>
      <long>35th Euromicro Conference on Real-Time Systems</long>
    </booktitle>
    <year>2023</year>
    <month>7</month>
    <hal>04654624</hal>
    <doi>10.4230/LIPIcs.ECRTS.2023.19</doi>
    <volume>262</volume>
    <series>Leibniz International Proceedings in Informatics (LIPIcs)</series>
    <publisher>Schloss Dagstuhl</publisher>
    <referto key="ecrts2023artifact">A companion paper, describing the artifacts
      used to answer the challenge appears in _Dagstuhl Artifacts Series (DARTS)_
      9(1), jul 2023.</referto>
    <abstract>
      <p>We present here the main features and lessons learned from the first edition of what has
        now become the ECRTS industrial challenge, together with the final description of the
        challenge and a comparative overview of the proposed solutions. This verification challenge,
        proposed by Thales, was first discussed in 2014 as part of a dedicated workshop (FMTV, a
        satellite event of the FM 2014 conference), and solutions were discussed for the first time
        at the WATERS 2015 workshop. The use case for the verification challenge is an aerial video
        tracking system. A specificity of this system lies in the fact that periods are constant but
        known with a limited precision only. The first part of the challenge focuses on the video
        frame processing system. It consists in computing maximum values of the end-to-end latency
        of the frames sent by the camera to the display, for two different buffer sizes, and then
        the minimum duration between two consecutive frame losses. The second challenge is about
        computing end-to-end latencies on the tracking and camera control for two different values
        of jitter. Solutions based on five different tools - Fiacre/Tina, CPAL (simulation and
        analysis), IMITATOR, UPPAAL and MAST - were submitted for discussion at WATERS 2015. While
        none of these solutions provided a full answer to the challenge, a combination of several of
        them did allow to draw some conclusions. </p>
    </abstract>
    <tags>Verification, Time Petri nets, Use Case, Fiacre, Tina</tags>
  </inproceedings>

  <article key="ras2023hippo">
    <authors>
      <author>&dalzilio;</author>
      <author>&hladik;</author>
      <author>
        <name>Ingrand</name>
        <forename>Félix</forename>
      </author>
      <author>
        <name>Anthony</name>
        <forename>Mallet</forename>
      </author>
    </authors>
    <title>A formal toolchain for offline and run-time verification of robotic systems</title>
    <journal>Robotics and Autonomous Systems</journal>
    <year>2023</year>
    <volume>159</volume>
    <publisher>Elsevier</publisher>
    <month>1</month>
    <hal>03683044</hal>
    <doi>10.1016/j.robot.2022.104301</doi>
    <abstract>
      <p>Validation and Verification (V&#x26;V) of autonomous robotic system software is becoming a
        critical issue. Among the V&#x26;V techniques at our disposal, formal approaches are among
        the most rigorous and trustworthy ones. Yet, the level of skills and knowledge required to
        use and deploy formal methods is usually quite high and rare. In this paper, we describe an
        approach that starts from a regular, but rigorous, framework to specify and deploy robotic
        software components, which can also automatically synthesize a formal model of these
        components.</p>

      <p>We describe how we can execute the resulting formal model, in place of a traditional
        implementation, and show how this provides the opportunity to add powerful monitoring and
        runtime verification capabilities to a system, e.g., to prevent collisions, or trigger an
        emergency landing. Since the runtime used to execute formal models is specifically designed
        to be faithful to their semantics, every execution (in the implementation) can be mapped to
        a trace in the specification. As a result, we can also prove many interesting properties
        offline, using model-checking techniques. We give several examples, such as properties about
        schedulability, worst-case traversal time, or mutual exclusion.</p>

      <p>We believe that having a consistent workflow, from an initial specification of our system,
        down to a formal, executable specification is a major advance in robotics and opens the way
        for verification of functional components of autonomous robots and beyond. We illustrate
        this claim by describing a complete example based on a genuine drone flight controller.</p>
    </abstract>
    <tags>Verification, Robotics, Fiacre, Hippo</tags>
  </article>

  <inproceedings key="vmcai2024octant">
    <authors>
      <author>&namat;</author>
      <author>&dalzilio;</author>
      <author>&didier;</author>
    </authors>
    <title>Project and Conquer: Fast Quantifier Elimination for Checking Petri Net Reachability</title>
    <booktitle>
      <short>VMCAI 2024</short>
      <long>Verification, Model Checking, and Abstract Interpretation</long>
    </booktitle>
    <year>2024</year>
    <month>1</month>
    <hal>04375443</hal>
    <doi>10.1007/978-3-031-50524-9_5</doi>
    <volume>14499</volume>
    <series>&LNCS;</series>
    <publisher>&SV;</publisher>
    <abstract>
      <p>We propose a method for checking generalized reachability properties in Petri nets that
        takes advantage of structural reductions and that can be used, transparently, as a
        pre-processing step of existing model-checkers. Our approach is based on a new procedure
        that can project a property, about an initial Petri net, into an equivalent formula that
        only refers to the reduced version of this net. Our projection is defined as a variable
        elimination procedure for linear integer arithmetic tailored to the specific kind of
        constraints we handle. It has linear complexity, is guaranteed to return a sound property,
        and makes use of a simple condition to detect when the result is exact. Experimental results
        show that our approach works well in practice and that it can be useful even when there is
        only a limited amount of reductions.</p>
    </abstract>
    <tags>Verification, Petri, Tools, Reductions, Octant</tags>
  </inproceedings>

</bibliography>